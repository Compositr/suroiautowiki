{
  "version": 3,
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/vendor/suroi/common/src/utils/objectDefinitions.ts"],"sourcesContent":["import { type ExplosionDefinition } from \"../definitions/explosions\";\nimport { type SuroiBitStream } from \"./suroiBitStream\";\nimport { type Vector } from \"./vector\";\n\n/**\n * A class representing a list of definitions\n * @template T The specific type of `ObjectDefinition` this class holds\n */\nexport class ObjectDefinitions<T extends ObjectDefinition = ObjectDefinition> {\n    readonly bitCount: number;\n    readonly definitions: T[];\n    readonly idStringToNumber: Record<string, number> = {};\n\n    constructor(definitions: T[]) {\n        this.bitCount = Math.ceil(Math.log2(definitions.length));\n\n        this.definitions = definitions;\n\n        for (let i = 0, defLength = definitions.length; i < defLength; i++) {\n            const idString = definitions[i].idString;\n            if (this.idStringToNumber[idString] !== undefined) {\n                throw new Error(`Duplicated idString: ${idString}`);\n            }\n            this.idStringToNumber[idString] = i;\n        }\n    }\n\n    reify<U extends T = T>(type: ReifiableDef<T>): U {\n        return typeof type === \"string\"\n            ? this.fromString<U>(type)\n            : type as U;\n    }\n\n    fromString<U extends T = T>(idString: ReferenceTo<U>): U {\n        const id = this.idStringToNumber[idString];\n        if (id === undefined) throw new Error(`Unknown idString: ${idString}`);\n        return this.definitions[id] as U;\n    }\n\n    writeToStream(stream: SuroiBitStream, type: ReifiableDef<T>): void {\n        stream.writeBits(\n            this.idStringToNumber[\n                typeof type === \"string\" ? type : type.idString\n            ],\n            this.bitCount\n        );\n    }\n\n    readFromStream<U extends T = T>(stream: SuroiBitStream): U {\n        const id = stream.readBits(this.bitCount);\n        if (id >= this.definitions.length) {\n            console.warn(`ID out of range: ${id} (max: ${this.definitions.length - 1})`);\n        }\n\n        return this.definitions[id] as U;\n    }\n\n    [Symbol.iterator](): Iterator<T> {\n        return this.definitions[Symbol.iterator]();\n    }\n}\n\nexport interface ObjectDefinition {\n    readonly idString: string\n    readonly name: string\n}\n\n/**\n * Semantically equivalent to `string`, this type is more to convey an intent\n */\nexport type ReferenceTo<T extends ObjectDefinition = ObjectDefinition> = T[\"idString\"];\n\nexport type ReifiableDef<T extends ObjectDefinition> = ReferenceTo<T> | T;\n\n// expand this as needed\nexport enum ItemType {\n    Gun,\n    Ammo,\n    Melee,\n    Throwable,\n    Healing,\n    Armor,\n    Backpack,\n    Scope,\n    Skin\n}\n\nexport enum ObstacleSpecialRoles {\n    Door,\n    Wall,\n    Window,\n    Activatable\n}\n\nexport enum MapObjectSpawnMode {\n    Grass,\n    /**\n     * Grass, beach and river banks.\n     */\n    GrassAndSand,\n    RiverBank,\n    River,\n    Beach\n}\n\nexport const LootRadius: Record<ItemType, number> = {\n    [ItemType.Gun]: 3.4,\n    [ItemType.Ammo]: 2,\n    [ItemType.Melee]: 3,\n    [ItemType.Throwable]: 3,\n    [ItemType.Healing]: 2.5,\n    [ItemType.Armor]: 3,\n    [ItemType.Backpack]: 3,\n    [ItemType.Scope]: 3,\n    [ItemType.Skin]: 3\n};\n\nexport interface BaseBulletDefinition {\n    readonly damage: number\n    readonly obstacleMultiplier: number\n    readonly speed: number\n    readonly range: number\n    readonly penetration?: {\n        readonly players?: boolean\n        readonly obstacles?: boolean\n    }\n\n    readonly tracer?: {\n        readonly opacity?: number\n        readonly width?: number\n        readonly length?: number\n        readonly color?: number\n        readonly image?: string\n        // used by the radio bullet\n        // this will make it scale and fade in and out\n        readonly particle?: boolean\n        readonly zIndex?: number\n    }\n\n    readonly rangeVariance?: number\n    readonly shrapnel?: boolean\n    readonly onHitExplosion?: ReferenceTo<ExplosionDefinition>\n    readonly goToMouse?: boolean\n    readonly lastShotFX?: boolean\n    readonly noCollision?: boolean\n}\n\nexport interface WearerAttributes {\n    /**\n     * A number by which the player's maximum health will be multiplied\n     */\n    readonly maxHealth?: number\n    /**\n     * A number by which the player's maximum adrenaline will be multiplied\n     */\n    readonly maxAdrenaline?: number\n    /**\n     * A number that will be added to the player's minimum adrenaline. As the name implies,\n     * this dictates the point at which adrenaline will stop decaying\n     */\n    readonly minAdrenaline?: number\n    /**\n     * A number by which the player's base speed will be multiplied\n     */\n    readonly speedBoost?: number\n}\n\nexport interface ExtendedWearerAttributes extends WearerAttributes {\n    /**\n     *The upper limit after which this effect is no longer reapplied\n     */\n    readonly limit?: number\n    /**\n     * A fixed amount of HP restored\n     */\n    readonly healthRestored?: number\n    /**\n     * A fixed amount of adrenaline restored\n     */\n    readonly adrenalineRestored?: number\n}\n\nexport interface ItemDefinition extends ObjectDefinition {\n    readonly itemType: ItemType\n    readonly noDrop?: boolean\n}\n\nexport interface InventoryItemDefinition extends ItemDefinition {\n    readonly fists?: {\n        readonly left: Vector\n        readonly right: Vector\n    }\n    readonly killstreak?: boolean\n    readonly speedMultiplier: number\n    /**\n     * A set of attributes to modify the player this item belongs to\n     * All attributes stack, and all of them are removed as soon as\n     * the item is dropped\n     */\n    readonly wearerAttributes?: {\n        /**\n         * These attributes are applied when the item is in the player's\n         * inventory\n         */\n        readonly passive?: WearerAttributes\n        /**\n         * These attributes are applied when the item is the active item, and\n         * stack on top of the passive ones\n         */\n        readonly active?: WearerAttributes\n        /**\n         * These attributes are applied or removed when certain events occur\n         */\n        readonly on?: {\n            /**\n             * These attributes are applied whenever the player gets a kill\n             */\n            readonly kill?: Array<{\n                /**\n                 * The upper limit after which this effect is no longer reapplied\n                 */\n                readonly limit?: number\n                /**\n                 * A fixed amount of HP restored\n                 */\n                readonly healthRestored?: number\n                /**\n                 * A fixed amount of adrenaline restored\n                 */\n                readonly adrenalineRestored?: number\n            } & WearerAttributes>\n            /**\n             * These attributs are applied whenever the player deals damage\n             */\n            readonly damageDealt?: Array<{\n                /**\n                 * The upper limit after which this effect is no longer reapplied\n                 */\n                readonly limit?: number\n                /**\n                 * A fixed amount of HP restored\n                 */\n                readonly healthRestored?: number\n                /**\n                 * A fixed amount of adrenaline restored\n                 */\n                readonly adrenalineRestored?: number\n            } & WearerAttributes>\n        }\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAQO,MAAM;IACA,SAAiB;IACjB,YAAiB;IACjB,mBAA2C,CAAC,EAAE;IAEvD,YAAY,WAAgB,CAAE;QAC1B,IAAI,CAAC,QAAQ,GAAG,KAAK,IAAI,CAAC,KAAK,IAAI,CAAC,YAAY,MAAM;QAEtD,IAAI,CAAC,WAAW,GAAG;QAEnB,IAAK,IAAI,IAAI,GAAG,YAAY,YAAY,MAAM,EAAE,IAAI,WAAW,IAAK;YAChE,MAAM,WAAW,WAAW,CAAC,EAAE,CAAC,QAAQ;YACxC,IAAI,IAAI,CAAC,gBAAgB,CAAC,SAAS,KAAK,WAAW;gBAC/C,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,SAAS,CAAC;YACtD;YACA,IAAI,CAAC,gBAAgB,CAAC,SAAS,GAAG;QACtC;IACJ;IAEA,MAAuB,IAAqB,EAAK;QAC7C,OAAO,OAAO,SAAS,WACjB,IAAI,CAAC,UAAU,CAAI,QACnB;IACV;IAEA,WAA4B,QAAwB,EAAK;QACrD,MAAM,KAAK,IAAI,CAAC,gBAAgB,CAAC,SAAS;QAC1C,IAAI,OAAO,WAAW,MAAM,IAAI,MAAM,CAAC,kBAAkB,EAAE,SAAS,CAAC;QACrE,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG;IAC/B;IAEA,cAAc,MAAsB,EAAE,IAAqB,EAAQ;QAC/D,OAAO,SAAS,CACZ,IAAI,CAAC,gBAAgB,CACjB,OAAO,SAAS,WAAW,OAAO,KAAK,QAAQ,CAClD,EACD,IAAI,CAAC,QAAQ;IAErB;IAEA,eAAgC,MAAsB,EAAK;QACvD,MAAM,KAAK,OAAO,QAAQ,CAAC,IAAI,CAAC,QAAQ;QACxC,IAAI,MAAM,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE;YAC/B,QAAQ,IAAI,CAAC,CAAC,iBAAiB,EAAE,GAAG,OAAO,EAAE,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,EAAE,CAAC,CAAC;QAC/E;QAEA,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG;IAC/B;IAEA,CAAC,OAAO,QAAQ,CAAC,GAAgB;QAC7B,OAAO,IAAI,CAAC,WAAW,CAAC,OAAO,QAAQ,CAAC;IAC5C;AACJ;;UAeY;;;;;;;;;;GAAA,aAAA;;UAYA;;;;;GAAA,yBAAA;;UAOA;;IAER;;KAEC;;;;GAJO,uBAAA;AAWL,MAAM,aAAuC;IAChD,GAAc,EAAE;IAChB,GAAe,EAAE;IACjB,GAAgB,EAAE;IAClB,GAAoB,EAAE;IACtB,GAAkB,EAAE;IACpB,GAAgB,EAAE;IAClB,GAAmB,EAAE;IACrB,GAAgB,EAAE;IAClB,GAAe,EAAE;AACrB"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/vendor/suroi/common/src/utils/misc.ts"],"sourcesContent":["export function isObject(item: unknown): item is Record<string, unknown> {\n    return (item && typeof item === \"object\" && !Array.isArray(item)) as boolean;\n}\n\nexport type DeepPartial<T> = {\n    [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];\n};\n\nexport type DeepRequired<T> = T extends Array<infer R>\n    ? Array<DeepRequired<NonNullable<R>>>\n    : {\n        [K in keyof T]-?: DeepRequired<NonNullable<T[K]>>;\n    };\n\nexport type DeepReadonly<T> = {\n    readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];\n};\n\nexport function mergeDeep<T extends object>(target: T, ...sources: Array<DeepPartial<T>>): T {\n    if (!sources.length) return target;\n\n    const [source, ...rest] = sources;\n\n    for (const _key in source) {\n        const key: keyof T = _key;\n\n        const [sourceProp, targetProp] = [source[key], target[key]];\n        if (isObject(targetProp)) {\n            mergeDeep(targetProp, sourceProp as DeepPartial<T[keyof T] & object>);\n            continue;\n        }\n\n        target[key] = sourceProp as T[keyof T];\n    }\n\n    return mergeDeep(target, ...rest);\n}\n\nexport function cloneDeep<T>(object: T): T {\n    if (!isObject(object)) return object;\n\n    const clone = new (Object.getPrototypeOf(object).constructor)();\n\n    for (const [key, desc] of Object.entries(Object.getOwnPropertyDescriptors(object))) {\n        const clonedProperty = object[key as keyof T];\n\n        desc.value = cloneDeep(clonedProperty);\n        Object.defineProperty(clone, key, desc);\n    }\n\n    return clone;\n}\n\nexport function freezeDeep<T>(object: T): DeepReadonly<T> {\n    Object.freeze(object);\n\n    for (const key in object) {\n        const value = object[key];\n\n        if (typeof value === \"object\" && value !== null) {\n            freezeDeep(value);\n        }\n    }\n\n    return object;\n}\n\nexport class Timeout {\n    callback: () => void;\n    end: number;\n    killed = false;\n\n    constructor(callback: () => void, end: number) {\n        this.end = end;\n        this.callback = callback;\n    }\n\n    kill(): void {\n        this.killed = true;\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAAO,SAAS,SAAS,IAAa;IAClC,OAAQ,QAAQ,OAAO,SAAS,YAAY,CAAC,MAAM,OAAO,CAAC;AAC/D;AAgBO,SAAS,UAA4B,MAAS,EAAE,GAAG,OAA8B;IACpF,IAAI,CAAC,QAAQ,MAAM,EAAE,OAAO;IAE5B,MAAM,CAAC,QAAQ,GAAG,KAAK,GAAG;IAE1B,IAAK,MAAM,QAAQ,OAAQ;QACvB,MAAM,MAAe;QAErB,MAAM,CAAC,YAAY,WAAW,GAAG;YAAC,MAAM,CAAC,IAAI;YAAE,MAAM,CAAC,IAAI;SAAC;QAC3D,IAAI,SAAS,aAAa;YACtB,UAAU,YAAY;YACtB;QACJ;QAEA,MAAM,CAAC,IAAI,GAAG;IAClB;IAEA,OAAO,UAAU,WAAW;AAChC;AAEO,SAAS,UAAa,MAAS;IAClC,IAAI,CAAC,SAAS,SAAS,OAAO;IAE9B,MAAM,QAAQ,IAAK,CAAA,OAAO,cAAc,CAAC,OAAM,EAAE,WAAW;IAE5D,KAAK,MAAM,CAAC,KAAK,KAAK,IAAI,OAAO,OAAO,CAAC,OAAO,yBAAyB,CAAC,SAAU;QAChF,MAAM,iBAAiB,MAAM,CAAC,IAAe;QAE7C,KAAK,KAAK,GAAG,UAAU;QACvB,OAAO,cAAc,CAAC,OAAO,KAAK;IACtC;IAEA,OAAO;AACX;AAEO,SAAS,WAAc,MAAS;IACnC,OAAO,MAAM,CAAC;IAEd,IAAK,MAAM,OAAO,OAAQ;QACtB,MAAM,QAAQ,MAAM,CAAC,IAAI;QAEzB,IAAI,OAAO,UAAU,YAAY,UAAU,MAAM;YAC7C,WAAW;QACf;IACJ;IAEA,OAAO;AACX;AAEO,MAAM;IACT,SAAqB;IACrB,IAAY;IACZ,SAAS,MAAM;IAEf,YAAY,QAAoB,EAAE,GAAW,CAAE;QAC3C,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,QAAQ,GAAG;IACpB;IAEA,OAAa;QACT,IAAI,CAAC,MAAM,GAAG;IAClB;AACJ"}},
    {"offset": {"line": 153, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 158, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/vendor/suroi/common/src/utils/vector.ts"],"sourcesContent":["import { type Orientation } from \"../typings\";\n\n/**\n * An interface to represent a 2D vector. The x and y values are coordinates in a 2D space\n */\nexport interface Vector {\n    x: number\n    y: number\n}\n\nexport const Vec = Object.freeze({\n    /**\n     * Creates a new `Vector`\n     * @param x The horizontal (x-axis) coordinate\n     * @param y The vertical (y-axis) coordinate\n     * @returns A new `Vector` object with the provided x and y coordinates\n     */\n    create(x: number, y: number): Vector {\n        return { x, y };\n    },\n    /**\n     * Adds two `Vector`s together\n     * @param a The first `Vector`\n     * @param b The second `Vector`\n     * @returns A new `Vector` resulting from the addition of vectors `a` and `b`\n     */\n    add(a: Vector, b: Vector): Vector {\n        return this.create(a.x + b.x, a.y + b.y);\n    },\n    /**\n     * Adds two vectors together\n     * @param a The first `Vector`\n     * @param x The x-coordinate of the second vector\n     * @param y The y-coordinate of the second vector\n     * @returns A new `Vector` resulting from the addition of `a`, and `x` and `y`\n     */\n    addComponent(a: Vector, x: number, y: number): Vector {\n        return this.create(a.x + x, a.y + y);\n    },\n    /**\n     * Subtracts one `Vector` from another\n     * @param a The `Vector` to be subtracted from\n     * @param b The `Vector` to subtract\n     * @returns A new `Vector` resulting from the subtraction of vector `b` from vector `a`\n     */\n    sub(a: Vector, b: Vector): Vector {\n        return this.create(a.x - b.x, a.y - b.y);\n    },\n    /**\n     * Multiplies a `Vector` by a scalar\n     * @param a The `Vector` to be multiplied\n     * @param n The scalar value to multiply the `Vector` by\n     * @returns A new `Vector` resulting from the multiplication of vector `a` and scalar `n`\n     */\n    scale(a: Vector, n: number): Vector {\n        return this.create(a.x * n, a.y * n);\n    },\n    /**\n     * Clones a `Vector`\n     * @param vector The `Vector` to be cloned\n     * @returns A new `Vector` with the same components as the input `Vector`\n     */\n    clone(vector: Vector): Vector {\n        return this.create(vector.x, vector.y);\n    },\n    /**\n     * Rotates a `Vector` by a given angle\n     * @param vector The `Vector` to be rotated\n     * @param angle The angle in radians to rotate the `Vector` by\n     * @returns A new `Vector` resulting from the rotation of the input `Vector` by the given angle\n     */\n    rotate(vector: Vector, angle: number): Vector {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        return this.create(vector.x * cos - vector.y * sin, vector.x * sin + vector.y * cos);\n    },\n    /**\n     * Returns the squared length of a `Vector`\n     * @param a The `Vector` to be measured\n     * @returns The length of the `Vector` `a`, squared\n     */\n    squaredLength(a: Vector): number {\n        return a.x * a.x + a.y * a.y;\n    },\n    /**\n     * Returns the length of a `Vector`\n     * @param a The vector to be measured\n     * @returns The length of the `Vector` `a`\n     */\n    length(a: Vector): number {\n        return Math.sqrt(Vec.squaredLength(a));\n    },\n    /**\n     * Performs the dot product between two vectors, returning the result. This operation is commutative\n     * @param a The first `Vector`\n     * @param b The second `Vector`\n     * @returns The result of performing the dot product using the component method\n     */\n    dotProduct(a: Vector, b: Vector): number {\n        return a.x * b.x + a.y * b.y;\n    },\n    /**\n     * Projects a `Vector` onto another\n     * @param projected The `Vector` to be projected\n     * @param projectOnto The `Vector` that will be projected onto\n     * @returns A new `Vector` parallel to `projectOnto` which is the projection of `projected`\n     */\n    project(projected: Vector, projectOnto: Vector): Vector {\n        return this.scale(projectOnto, this.dotProduct(projected, projectOnto) / this.squaredLength(projectOnto));\n    },\n    /**\n     * Creates a new `Vector` parallel to the original, but whose length is 1\n     * @param a The `Vector` to normalize\n     * @param fallback A `Vector` to clone and return in case the normalization operation fails\n     * @returns A `Vector` whose length is 1 and is parallel to the original vector\n     */\n    normalizeSafe(a: Vector, fallback?: Vector): Vector {\n        fallback ??= this.create(1.0, 0.0);\n        const eps = 0.000001;\n        const len = Vec.length(a);\n        return len > eps\n            ? {\n                x: a.x / len,\n                y: a.y / len\n            }\n            : Vec.clone(fallback);\n    },\n    /**\n     * Creates a new `Vector` parallel to the original, but whose length is 1\n     * @param a The `Vector` to normalize\n     * @returns A `Vector` whose length is 1 and is parallel to the original vector\n     */\n    normalize(a: Vector): Vector {\n        const eps = 0.000001;\n        const len = Vec.length(a);\n        return eps\n            ? {\n                x: a.x / len,\n                y: a.y / len\n            }\n            : Vec.clone(a);\n    },\n    /**\n     * Returns the additive inverse of this vector; in other words, a `Vector` that, when added to this one, gives the zero vector\n     * @param a The `Vector` to invert\n     * @returns A `Vector` whose components are -1 multiplied by the corresponding component in the original `Vector`\n     */\n    invert(a: Vector): Vector {\n        return this.create(-a.x, -a.y);\n    },\n    /**\n     * Tests whether two `Vectors` are equal, within a certain tolerance\n     * @param a The first `Vector`\n     * @param b The second `Vector`\n     * @param epsilon The largest difference in any component that will be accepted as being \"equal\"\n     * @returns Whether or not the two vectors are considered equal with the given epsilon\n     */\n    equals(a: Vector, b: Vector, epsilon = 0.001): boolean {\n        return Math.abs(a.x - b.x) <= epsilon && Math.abs(a.y - b.y) <= epsilon;\n    },\n    /**\n     * Returns the angle between two vectors\n     * @param a The first vector\n     * @param b The second vector\n     */\n    angleBetweenVectors(a: Vector, b: Vector): number {\n        return Math.acos((a.x * b.x + a.y * b.y) / Math.sqrt(Vec.length(a) * Vec.length(b)));\n    },\n    /**\n     * Interpolate between two `Vector`s\n     * @param start The start `Vector`\n     * @param end The end `Vector`\n     * @param interpFactor The interpolation factor ranging from 0 to 1\n     *\n     */\n    lerp(start: Vector, end: Vector, interpFactor: number): Vector {\n        return Vec.add(Vec.scale(start, 1 - interpFactor), Vec.scale(end, interpFactor));\n    },\n    /**\n     * Takes a polar representation of a vector and converts it into a cartesian one\n     * @param angle The vector's angle\n     * @param magnitude The vector's length. Defaults to 1\n     * @returns A new vector whose length is `magnitude` and whose direction is `angle`\n     */\n    fromPolar(angle: number, magnitude = 1): Vector {\n        return {\n            x: Math.cos(angle) * magnitude,\n            y: Math.sin(angle) * magnitude\n        };\n    },\n    /**\n     * Add a `Vector` to another one and rotate it by the given orientation\n     * @param position1 The initial `Vector`\n     * @param position2 The `Vector` to add to the first one\n     * @param orientation The orientation to rotate the second vector by\n     * @return A new `Vector`\n     */\n    addAdjust(position1: Vector, position2: Vector, orientation: Orientation): Vector {\n        if (orientation === 0) return Vec.add(position1, position2);\n        let xOffset: number, yOffset: number;\n        switch (orientation) {\n            case 1:\n                // noinspection JSSuspiciousNameCombination\n                xOffset = position2.y;\n                yOffset = -position2.x;\n                break;\n            case 2:\n                xOffset = -position2.x;\n                yOffset = -position2.y;\n                break;\n            case 3:\n                xOffset = -position2.y;\n                // noinspection JSSuspiciousNameCombination\n                yOffset = position2.x;\n                break;\n        }\n        return Vec.add(position1, Vec.create(xOffset, yOffset));\n    }\n});\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 355, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/vendor/suroi/common/src/definitions/throwables.ts"],"sourcesContent":["import { ItemType, type InventoryItemDefinition, type ReferenceTo } from \"../utils/objectDefinitions\";\nimport { Vec, type Vector } from \"../utils/vector\";\nimport { type ExplosionDefinition } from \"./explosions\";\n\nexport type ThrowableDefinition = InventoryItemDefinition & {\n    readonly itemType: ItemType.Throwable\n    /**\n     * Specified in *milliseconds*\n     */\n    readonly fuseTime: number\n    readonly cookTime: number\n    readonly throwTime: number\n    /**\n     * Whether cooking the grenade will run down the fuse\n     */\n    readonly cookable: boolean\n    readonly cookSpeedMultiplier: number\n    readonly maxThrowDistance: number\n    readonly image: {\n        readonly position: Vector\n        readonly angle?: number\n    }\n    readonly radius: number\n    readonly fireDelay?: number\n    readonly detonation: {\n        readonly explosion?: ReferenceTo<ExplosionDefinition>\n    }\n    readonly animation: {\n        readonly pinImage: string\n        readonly liveImage: string\n        readonly leverImage: string\n        readonly cook: {\n            readonly cookingImage?: string\n            readonly leftFist: Vector\n            readonly rightFist: Vector\n        }\n        readonly throw: {\n            readonly leftFist: Vector\n            readonly rightFist: Vector\n        }\n    }\n} & ({\n    readonly impactDamage: number\n    /**\n     * Applies to impact damage and not explosion damage\n     */\n    readonly obstacleMultiplier?: number\n} | {\n    readonly impactDamage?: undefined\n});\n\nexport const Throwables: ThrowableDefinition[] = [\n    {\n        idString: \"frag_grenade\",\n        name: \"Frag Grenade\",\n        itemType: ItemType.Throwable,\n        speedMultiplier: 0.92,\n        cookSpeedMultiplier: 0.7,\n        radius: 1,\n        impactDamage: 1,\n        obstacleMultiplier: 20,\n        fuseTime: 4000,\n        cookTime: 250,\n        throwTime: 150,\n        cookable: true,\n        maxThrowDistance: 96,\n        fireDelay: 500,\n        image: {\n            position: Vec.create(60, 43),\n            angle: 60\n        },\n        detonation: {\n            explosion: \"frag_explosion\"\n        },\n        animation: {\n            pinImage: \"proj_frag_pin\",\n            liveImage: \"proj_frag\",\n            leverImage: \"proj_frag_lever\",\n            cook: {\n                leftFist: Vec.create(2.5, 0),\n                rightFist: Vec.create(-0.5, 2.15)\n            },\n            throw: {\n                leftFist: Vec.create(1.9, -1.75),\n                rightFist: Vec.create(4, 2.15)\n            }\n        }\n    },\n    {\n        idString: \"smoke_grenade\",\n        name: \"Smoke Grenade\",\n        itemType: ItemType.Throwable,\n        speedMultiplier: 0.92,\n        cookSpeedMultiplier: 0.7,\n        radius: 1,\n        impactDamage: 1,\n        obstacleMultiplier: 20,\n        cookable: false,\n        fuseTime: 2000,\n        cookTime: 250,\n        throwTime: 150,\n        maxThrowDistance: 96,\n        image: {\n            position: Vec.create(60, 43),\n            angle: 60\n        },\n        detonation: {\n            explosion: \"smoke_explosion\"\n        },\n        animation: {\n            pinImage: \"proj_smoke_pin\",\n            liveImage: \"proj_smoke\",\n            leverImage: \"proj_smoke_lever\",\n            cook: {\n                cookingImage: \"proj_smoke_nopin\",\n                leftFist: Vec.create(2.5, 0),\n                rightFist: Vec.create(-0.5, 2.15)\n            },\n            throw: {\n                leftFist: Vec.create(1.9, -1.75),\n                rightFist: Vec.create(4, 2.15)\n            }\n        }\n    }\n];\n"],"names":[],"mappings":";;;;;;;;AAmDO,MAAM,aAAoC;IAC7C;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,SAAS;QAC5B,iBAAiB;QACjB,qBAAqB;QACrB,QAAQ;QACR,cAAc;QACd,oBAAoB;QACpB,UAAU;QACV,UAAU;QACV,WAAW;QACX,UAAU;QACV,kBAAkB;QAClB,WAAW;QACX,OAAO;YACH,UAAU,8JAAI,MAAM,CAAC,IAAI;YACzB,OAAO;QACX;QACA,YAAY;YACR,WAAW;QACf;QACA,WAAW;YACP,UAAU;YACV,WAAW;YACX,YAAY;YACZ,MAAM;gBACF,UAAU,8JAAI,MAAM,CAAC,KAAK;gBAC1B,WAAW,8JAAI,MAAM,CAAC,CAAC,KAAK;YAChC;YACA,OAAO;gBACH,UAAU,8JAAI,MAAM,CAAC,KAAK,CAAC;gBAC3B,WAAW,8JAAI,MAAM,CAAC,GAAG;YAC7B;QACJ;IACJ;IACA;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,SAAS;QAC5B,iBAAiB;QACjB,qBAAqB;QACrB,QAAQ;QACR,cAAc;QACd,oBAAoB;QACpB,UAAU;QACV,UAAU;QACV,UAAU;QACV,WAAW;QACX,kBAAkB;QAClB,OAAO;YACH,UAAU,8JAAI,MAAM,CAAC,IAAI;YACzB,OAAO;QACX;QACA,YAAY;YACR,WAAW;QACf;QACA,WAAW;YACP,UAAU;YACV,WAAW;YACX,YAAY;YACZ,MAAM;gBACF,cAAc;gBACd,UAAU,8JAAI,MAAM,CAAC,KAAK;gBAC1B,WAAW,8JAAI,MAAM,CAAC,CAAC,KAAK;YAChC;YACA,OAAO;gBACH,UAAU,8JAAI,MAAM,CAAC,KAAK,CAAC;gBAC3B,WAAW,8JAAI,MAAM,CAAC,GAAG;YAC7B;QACJ;IACJ;CACH"}},
    {"offset": {"line": 437, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 442, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/vendor/suroi/common/src/definitions/scopes.ts"],"sourcesContent":["import { ItemType, ObjectDefinitions, type ItemDefinition } from \"../utils/objectDefinitions\";\n\nexport interface ScopeDefinition extends ItemDefinition {\n    readonly itemType: ItemType.Scope\n    readonly zoomLevel: number\n    readonly giveByDefault?: boolean\n}\n\nexport const Scopes = new ObjectDefinitions<ScopeDefinition>([\n    {\n        idString: \"1x_scope\",\n        name: \"1x Scope\",\n        itemType: ItemType.Scope,\n        zoomLevel: 48,\n        noDrop: true,\n        giveByDefault: true\n    },\n    {\n        idString: \"2x_scope\",\n        name: \"2x Scope\",\n        itemType: ItemType.Scope,\n        zoomLevel: 62\n    },\n    {\n        idString: \"4x_scope\",\n        name: \"4x Scope\",\n        itemType: ItemType.Scope,\n        zoomLevel: 83\n    },\n    {\n        idString: \"8x_scope\",\n        name: \"8x Scope\",\n        itemType: ItemType.Scope,\n        zoomLevel: 116\n    },\n    {\n        idString: \"15x_scope\",\n        name: \"15x Scope\",\n        itemType: ItemType.Scope,\n        zoomLevel: 178\n    }\n]);\n"],"names":[],"mappings":";;;;;;AAQO,MAAM,SAAS,2LAAuC;IACzD;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,KAAK;QACxB,WAAW;QACX,QAAQ;QACR,eAAe;IACnB;IACA;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,KAAK;QACxB,WAAW;IACf;IACA;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,KAAK;QACxB,WAAW;IACf;IACA;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,KAAK;QACxB,WAAW;IACf;IACA;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,KAAK;QACxB,WAAW;IACf;CACH"}},
    {"offset": {"line": 482, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 487, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/vendor/suroi/common/src/definitions/healingItems.ts"],"sourcesContent":["import { ItemType, ObjectDefinitions, type ItemDefinition } from \"../utils/objectDefinitions\";\n\nexport interface HealingItemDefinition extends ItemDefinition {\n    readonly itemType: ItemType.Healing\n    readonly healType: HealType\n    readonly restoreAmount: number\n    readonly useTime: number\n    readonly useText: string\n}\n\nexport enum HealType {\n    Health,\n    Adrenaline\n}\n\nexport const HealingItems = new ObjectDefinitions<HealingItemDefinition>([\n    {\n        idString: \"gauze\",\n        name: \"Gauze\",\n        itemType: ItemType.Healing,\n        healType: HealType.Health,\n        restoreAmount: 15,\n        useTime: 3,\n        useText: \"Applying\"\n    },\n    {\n        idString: \"medikit\",\n        name: \"Medikit\",\n        itemType: ItemType.Healing,\n        healType: HealType.Health,\n        restoreAmount: 100,\n        useTime: 6,\n        useText: \"Using\"\n    },\n    {\n        idString: \"cola\",\n        name: \"Cola\",\n        itemType: ItemType.Healing,\n        healType: HealType.Adrenaline,\n        restoreAmount: 25,\n        useTime: 3,\n        useText: \"Drinking\"\n    },\n    {\n        idString: \"tablets\",\n        name: \"Tablets\",\n        itemType: ItemType.Healing,\n        healType: HealType.Adrenaline,\n        restoreAmount: 50,\n        useTime: 5,\n        useText: \"Taking\"\n    }\n]);\n"],"names":[],"mappings":";;;;;;;;UAUY;;;GAAA,aAAA;AAKL,MAAM,eAAe,2LAA6C;IACrE;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,OAAO;QAC1B,QAAQ;QACR,eAAe;QACf,SAAS;QACT,SAAS;IACb;IACA;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,OAAO;QAC1B,QAAQ;QACR,eAAe;QACf,SAAS;QACT,SAAS;IACb;IACA;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,OAAO;QAC1B,QAAQ;QACR,eAAe;QACf,SAAS;QACT,SAAS;IACb;IACA;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,OAAO;QAC1B,QAAQ;QACR,eAAe;QACf,SAAS;QACT,SAAS;IACb;CACH"}},
    {"offset": {"line": 537, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 542, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/vendor/suroi/common/src/definitions/ammos.ts"],"sourcesContent":["import { ItemType, ObjectDefinitions, type ItemDefinition } from \"../utils/objectDefinitions\";\n\nexport interface AmmoDefinition extends ItemDefinition {\n    readonly itemType: ItemType.Ammo\n    readonly maxStackSize: number\n    /**\n     * Marking an ammo type as `ephemeral` does the following:\n     * - All players start with it maxed out\n     * - It cannot be depleted nor dropped\n     * - It does not show up on the HUD\n     * - It can always be picked up\n     */\n    readonly ephemeral?: boolean\n    readonly hideUnlessPresent?: boolean\n}\n\nexport const Ammos = new ObjectDefinitions<AmmoDefinition>([\n    {\n        idString: \"12g\",\n        name: \"12 gauge\",\n        itemType: ItemType.Ammo,\n        maxStackSize: 20\n    },\n    {\n        idString: \"556mm\",\n        name: \"5.56mm\",\n        itemType: ItemType.Ammo,\n        maxStackSize: 60\n    },\n    {\n        idString: \"762mm\",\n        name: \"7.62mm\",\n        itemType: ItemType.Ammo,\n        maxStackSize: 60\n    },\n    {\n        idString: \"9mm\",\n        name: \"9mm\",\n        itemType: ItemType.Ammo,\n        maxStackSize: 90\n    },\n    {\n        idString: \"127mm\",\n        name: \"12.7mm\",\n        itemType: ItemType.Ammo,\n        maxStackSize: 10,\n        hideUnlessPresent: true\n    },\n    {\n        idString: \"curadell\",\n        name: \"Curadell\",\n        itemType: ItemType.Ammo,\n        maxStackSize: 10,\n        hideUnlessPresent: true\n    },\n    /*\n    {\n        idString: \"50ae\",\n        name: \".50 AE\",\n        itemType: ItemType.Ammo\n    }, */\n\n    // Ephemeral ammo types below\n\n    {\n        idString: \"power_cell\",\n        name: \"P.O.W.E.R. cell\",\n        itemType: ItemType.Ammo,\n        maxStackSize: 10,\n        ephemeral: true\n    },\n    {\n        idString: \"bb\",\n        name: \"6mm BB\",\n        itemType: ItemType.Ammo,\n        maxStackSize: 240,\n        ephemeral: true\n    }\n]);\n"],"names":[],"mappings":";;;;;;AAgBO,MAAM,QAAQ,2LAAsC;IACvD;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,IAAI;QACvB,cAAc;IAClB;IACA;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,IAAI;QACvB,cAAc;IAClB;IACA;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,IAAI;QACvB,cAAc;IAClB;IACA;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,IAAI;QACvB,cAAc;IAClB;IACA;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,IAAI;QACvB,cAAc;QACd,mBAAmB;IACvB;IACA;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,IAAI;QACvB,cAAc;QACd,mBAAmB;IACvB;IACA;;;;;OAKG,GAEH,6BAA6B;IAE7B;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,IAAI;QACvB,cAAc;QACd,WAAW;IACf;IACA;QACI,UAAU;QACV,MAAM;QACN,UAAU,8KAAS,IAAI;QACvB,cAAc;QACd,WAAW;IACf;CACH"}},
    {"offset": {"line": 608, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 613, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/vendor/suroi/common/src/constants.ts"],"sourcesContent":["import { Ammos } from \"./definitions/ammos\";\nimport { HealingItems } from \"./definitions/healingItems\";\nimport { Scopes } from \"./definitions/scopes\";\nimport { Throwables } from \"./definitions/throwables\";\nimport { freezeDeep } from \"./utils/misc\";\nimport { ItemType } from \"./utils/objectDefinitions\";\n\nexport enum ObjectCategory {\n    Player,\n    Obstacle,\n    DeathMarker,\n    Loot,\n    Building,\n    Decal,\n    Parachute,\n    ThrowableProjectile,\n    SyncedParticle\n}\n\nexport enum PacketType {\n    Join,\n    Joined,\n    Map,\n    Update,\n    Input,\n    GameOver,\n    Pickup,\n    Ping,\n    Spectate,\n    Report,\n    MapPing\n}\n\nexport enum AnimationType {\n    None,\n    Melee,\n    ThrowableCook,\n    ThrowableThrow,\n    Gun,\n    GunAlt,\n    GunClick,\n    LastShot\n}\n\nexport enum KillFeedMessageType {\n    Kill,\n    KillLeaderAssigned,\n    KillLeaderDead,\n    KillLeaderUpdated\n}\n\nexport enum GasState {\n    Inactive,\n    Waiting,\n    Advancing\n}\n\nexport enum FireMode {\n    Single,\n    Burst,\n    Auto\n}\n\nexport enum InputActions {\n    EquipItem,\n    EquipLastItem,\n    DropItem,\n    SwapGunSlots,\n    Interact,\n    Reload,\n    Cancel,\n    UseItem,\n    TopEmoteSlot,\n    RightEmoteSlot,\n    BottomEmoteSlot,\n    LeftEmoteSlot\n}\n\nexport enum SpectateActions {\n    BeginSpectating,\n    SpectatePrevious,\n    SpectateNext,\n    SpectateSpecific,\n    SpectateKillLeader,\n    Report\n}\n\nexport enum PlayerActions {\n    None,\n    Reload,\n    UseItem\n}\n\nexport enum KillType {\n    Suicide,\n    TwoPartyInteraction,\n    Gas,\n    Airdrop\n}\n\nexport const DEFAULT_INVENTORY: Record<string, number> = {};\n\nfor (const item of [...HealingItems, ...Ammos, ...Scopes, ...Throwables]) {\n    let amount = 0;\n\n    switch (true) {\n        case item.itemType === ItemType.Ammo && item.ephemeral: amount = Infinity; break;\n        case item.itemType === ItemType.Scope && item.giveByDefault: amount = 1; break;\n    }\n\n    DEFAULT_INVENTORY[item.idString] = amount;\n}\n\nObject.freeze(DEFAULT_INVENTORY);\n\nconst tickrate = 40;\nconst inventorySlotTypings = Object.freeze([ItemType.Gun, ItemType.Gun, ItemType.Melee, ItemType.Throwable] as const);\nexport const GameConstants = freezeDeep({\n    // !!!!! NOTE: Increase this every time a bit stream change is made between latest release and master\n    // or a new item is added to a definition list\n    protocolVersion: 12,\n    gridSize: 32,\n    tickrate,\n    // this is fine cause the object is frozen anyways, so\n    // these two attributes can't ever be desynced\n    msPerTick: 1000 / tickrate,\n    maxPosition: 1632,\n    player: {\n        radius: 2.25,\n        nameMaxLength: 16,\n        defaultName: \"Player\",\n        defaultHealth: 100,\n        maxAdrenaline: 100,\n        inventorySlotTypings,\n        maxWeapons: inventorySlotTypings.length,\n        killLeaderMinKills: 3,\n        maxMouseDist: 128\n    },\n    airdrop: {\n        fallTime: 8000,\n        flyTime: 30000,\n        damage: 300\n    }\n});\n\nexport enum ZIndexes {\n    Ground,\n    UnderWaterDeathMarkers,\n    UnderWaterDeadObstacles,\n    UnderWaterObstacles,\n    UnderWaterLoot,\n    UnderwaterPlayers,\n    BuildingsFloor,\n    Decals,\n    DeadObstacles,\n    DeathMarkers,\n    /**\n     * This is the default layer for obstacles\n     */\n    ObstaclesLayer1,\n    Loot,\n    ObstaclesLayer2,\n    Bullets,\n    Players,\n    /**\n     * bushes, tables etc\n     */\n    ObstaclesLayer3,\n    /**\n     * trees\n     */\n    ObstaclesLayer4,\n    BuildingsCeiling,\n    /**\n     * obstacles that should show on top of ceilings\n     */\n    ObstaclesLayer5,\n    Emotes,\n    Gas\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAOY;;;;;;;;;;GAAA,mBAAA;;UAYA;;;;;;;;;;;;GAAA,eAAA;;UAcA;;;;;;;;;GAAA,kBAAA;;UAWA;;;;;GAAA,wBAAA;;UAOA;;;;GAAA,aAAA;;UAMA;;;;GAAA,aAAA;;UAMA;;;;;;;;;;;;;GAAA,iBAAA;;UAeA;;;;;;;GAAA,oBAAA;;UASA;;;;GAAA,kBAAA;;UAMA;;;;;GAAA,aAAA;AAOL,MAAM,oBAA4C,CAAC;AAE1D,KAAK,MAAM,QAAQ;;;;;CAAqD,CAAE;IACtE,IAAI,SAAS;IAEb,OAAQ;QACJ,KAAK,KAAK,QAAQ,KAAK,8KAAS,IAAI,IAAI,KAAK,SAAS;YAAE,SAAS;YAAU;QAC3E,KAAK,KAAK,QAAQ,KAAK,8KAAS,KAAK,IAAI,KAAK,aAAa;YAAE,SAAS;YAAG;IAC7E;IAEA,iBAAiB,CAAC,KAAK,QAAQ,CAAC,GAAG;AACvC;AAEA,OAAO,MAAM,CAAC;AAEd,MAAM,WAAW;AACjB,MAAM,uBAAuB,OAAO,MAAM,CAAC;IAAC,8KAAS,GAAG;IAAE,8KAAS,GAAG;IAAE,8KAAS,KAAK;IAAE,8KAAS,SAAS;CAAC;AACpG,MAAM,gBAAgB,mKAAW;IACpC,qGAAqG;IACrG,8CAA8C;IAC9C,iBAAiB;IACjB,UAAU;IACV;IACA,sDAAsD;IACtD,8CAA8C;IAC9C,WAAW,OAAO;IAClB,aAAa;IACb,QAAQ;QACJ,QAAQ;QACR,eAAe;QACf,aAAa;QACb,eAAe;QACf,eAAe;QACf;QACA,YAAY,qBAAqB,MAAM;QACvC,oBAAoB;QACpB,cAAc;IAClB;IACA,SAAS;QACL,UAAU;QACV,SAAS;QACT,QAAQ;IACZ;AACJ;;UAEY;;;;;;;;;;;IAWR;;KAEC;;;;;IAMD;;KAEC;IAED;;KAEC;;IAGD;;KAEC;;;GA9BO,aAAA"}},
    {"offset": {"line": 819, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 824, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/vendor/suroi/common/src/utils/hitbox.ts"],"sourcesContent":["import { type Orientation } from \"../typings\";\nimport { Collision, Geometry, type CollisionRecord, type IntersectionResponse } from \"./math\";\nimport { pickRandomInArray, randomFloat, randomPointInsideCircle } from \"./random\";\nimport { Vec, type Vector } from \"./vector\";\n\nexport enum HitboxType {\n    Circle,\n    Rect,\n    Group,\n    Polygon\n}\n\nexport interface HitboxJSONMapping {\n    [HitboxType.Circle]: {\n        readonly type: HitboxType.Circle\n        readonly radius: number\n        readonly position: Vector\n    }\n    [HitboxType.Rect]: {\n        readonly type: HitboxType.Rect\n        readonly min: Vector\n        readonly max: Vector\n    }\n    [HitboxType.Group]: {\n        readonly type: HitboxType.Group\n        readonly hitboxes: Array<HitboxJSONMapping[HitboxType.Circle | HitboxType.Rect]>\n    }\n    [HitboxType.Polygon]: {\n        readonly type: HitboxType.Polygon\n        readonly points: Vector[]\n    }\n}\n\nexport type HitboxJSON = HitboxJSONMapping[HitboxType];\n\nexport interface HitboxMapping {\n    [HitboxType.Circle]: CircleHitbox\n    [HitboxType.Rect]: RectangleHitbox\n    [HitboxType.Group]: HitboxGroup\n    [HitboxType.Polygon]: PolygonHitbox\n}\n\nexport type Hitbox = HitboxMapping[HitboxType];\n\nexport abstract class BaseHitbox<T extends HitboxType = HitboxType> {\n    abstract type: HitboxType;\n\n    abstract toJSON(): HitboxJSONMapping[T];\n\n    static fromJSON(data: HitboxJSON): Hitbox {\n        switch (data.type) {\n            case HitboxType.Circle:\n                return new CircleHitbox(data.radius, data.position);\n            case HitboxType.Rect:\n                return new RectangleHitbox(data.min, data.max);\n            case HitboxType.Group:\n                return new HitboxGroup(\n                    ...data.hitboxes.map(d => BaseHitbox.fromJSON(d) as CircleHitbox | RectangleHitbox)\n                );\n            case HitboxType.Polygon:\n                return new PolygonHitbox(data.points);\n        }\n    }\n\n    /**\n     * Checks if this {@link Hitbox} collides with another one\n     * @param that The other {@link Hitbox}\n     * @return `true` if both {@link Hitbox}es collide\n     */\n    abstract collidesWith(that: Hitbox): boolean;\n    /**\n     * Resolve collision between {@link Hitbox}es.\n     * @param that The other {@link Hitbox}\n     */\n    abstract resolveCollision(that: Hitbox): void;\n    /**\n     * Get the distance from this {@link Hitbox} from another {@link Hitbox}.\n     * @param that The other {@link Hitbox}\n     * @return A {@link CollisionRecord} with the distance and if both {@link Hitbox}es collide\n     */\n    abstract distanceTo(that: Hitbox): CollisionRecord;\n    /**\n     * Clone this {@link Hitbox}.\n     * @return a new {@link Hitbox} cloned from this one\n     */\n    abstract clone(): Hitbox;\n    /**\n     * Transform this {@link Hitbox} and returns a new {@link Hitbox}.\n     * NOTE: This doesn't change the initial {@link Hitbox}\n     * @param position The position to transform the {@link Hitbox} by\n     * @param scale The scale to transform the {@link Hitbox}\n     * @param orientation The orientation to transform the {@link Hitbox}\n     * @return A new {@link Hitbox} transformed by the parameters\n     */\n    abstract transform(position: Vector, scale?: number, orientation?: Orientation): Hitbox;\n    /**\n     * Scale this {@link Hitbox}.\n     * NOTE: This does change the initial {@link Hitbox}\n     * @param scale The scale\n     */\n    abstract scale(scale: number): void;\n    /**\n     * Check if a line intersects with this {@link Hitbox}.\n     * @param a the start point of the line\n     * @param b the end point of the line\n     * @return An intersection response containing the intersection position and normal\n     */\n    abstract intersectsLine(a: Vector, b: Vector): IntersectionResponse;\n    /**\n     * Get a random position inside this {@link Hitbox}.\n     * @return A Vector of a random position inside this {@link Hitbox}\n     */\n    abstract randomPoint(): Vector;\n\n    abstract toRectangle(): RectangleHitbox;\n\n    abstract isPointInside(point: Vector): boolean;\n\n    abstract getCenter(): Vector;\n\n    protected throwUnknownSubclassError(that: Hitbox): never {\n        throw new Error(`Hitbox type ${HitboxType[this.type]} doesn't support this operation with hitbox type ${HitboxType[that.type]}`);\n    }\n}\n\nexport class CircleHitbox extends BaseHitbox<HitboxType.Circle> {\n    override readonly type = HitboxType.Circle;\n    position: Vector;\n    radius: number;\n\n    constructor(radius: number, position?: Vector) {\n        super();\n\n        this.position = position ?? Vec.create(0, 0);\n        this.radius = radius;\n    }\n\n    override toJSON(): HitboxJSONMapping[HitboxType.Circle] {\n        return {\n            type: this.type,\n            radius: this.radius,\n            position: Vec.clone(this.position)\n        };\n    }\n\n    override collidesWith(that: Hitbox): boolean {\n        switch (that.type) {\n            case HitboxType.Circle:\n                return Collision.circleCollision(that.position, that.radius, this.position, this.radius);\n            case HitboxType.Rect:\n                return Collision.rectangleCollision(that.min, that.max, this.position, this.radius);\n            case HitboxType.Group:\n                return that.collidesWith(this);\n            case HitboxType.Polygon:\n                // todo: proper circle to polygon detection\n                return that.collidesWith(this.toRectangle());\n        }\n    }\n\n    override resolveCollision(that: Hitbox): void {\n        switch (that.type) {\n            case HitboxType.Circle: {\n                const collision = Collision.circleCircleIntersection(this.position, this.radius, that.position, that.radius);\n\n                if (collision) {\n                    this.position = Vec.sub(this.position, Vec.scale(collision.dir, collision.pen));\n                }\n                break;\n            }\n            case HitboxType.Rect: {\n                const collision = Collision.rectCircleIntersection(that.min, that.max, this.position, this.radius);\n                if (collision) {\n                    this.position = Vec.sub(this.position, Vec.scale(collision.dir, collision.pen));\n                }\n                break;\n            }\n            case HitboxType.Group: {\n                for (const hitbox of that.hitboxes) {\n                    if (this.collidesWith(hitbox)) {\n                        this.resolveCollision(hitbox);\n                    }\n                }\n                break;\n            }\n            default: {\n                this.throwUnknownSubclassError(that);\n            }\n        }\n    }\n\n    override distanceTo(that: Hitbox): CollisionRecord {\n        switch (that.type) {\n            case HitboxType.Circle:\n                return Collision.distanceBetweenCircles(that.position, that.radius, this.position, this.radius);\n            case HitboxType.Rect:\n                return Collision.distanceBetweenRectangleCircle(that.min, that.max, this.position, this.radius);\n            default:\n                this.throwUnknownSubclassError(that);\n        }\n    }\n\n    override clone(): CircleHitbox {\n        return new CircleHitbox(this.radius, Vec.clone(this.position));\n    }\n\n    override transform(position: Vector, scale = 1, orientation = 0 as Orientation): CircleHitbox {\n        return new CircleHitbox(this.radius * scale, Vec.addAdjust(position, this.position, orientation));\n    }\n\n    override scale(scale: number): void {\n        this.radius *= scale;\n    }\n\n    override intersectsLine(a: Vector, b: Vector): IntersectionResponse {\n        return Collision.lineIntersectsCircle(a, b, this.position, this.radius);\n    }\n\n    override randomPoint(): Vector {\n        return randomPointInsideCircle(this.position, this.radius);\n    }\n\n    override toRectangle(): RectangleHitbox {\n        return new RectangleHitbox(Vec.create(this.position.x - this.radius, this.position.y - this.radius), Vec.create(this.position.x + this.radius, this.position.y + this.radius));\n    }\n\n    override isPointInside(point: Vector): boolean {\n        return Geometry.distance(point, this.position) < this.radius;\n    }\n\n    override getCenter(): Vector {\n        return this.position;\n    }\n}\n\nexport class RectangleHitbox extends BaseHitbox<HitboxType.Rect> {\n    override readonly type = HitboxType.Rect;\n    min: Vector;\n    max: Vector;\n\n    constructor(min: Vector, max: Vector) {\n        super();\n\n        this.min = min;\n        this.max = max;\n    }\n\n    toJSON(): HitboxJSONMapping[HitboxType.Rect] {\n        return {\n            type: this.type,\n            min: Vec.clone(this.min),\n            max: Vec.clone(this.max)\n        };\n    }\n\n    static fromLine(a: Vector, b: Vector): RectangleHitbox {\n        return new RectangleHitbox(\n            Vec.create(\n                Math.min(a.x, b.x),\n                Math.min(a.y, b.y)\n            ),\n            Vec.create(\n                Math.max(a.x, b.x),\n                Math.max(a.y, b.y)\n            )\n        );\n    }\n\n    static fromRect(width: number, height: number, pos = Vec.create(0, 0)): RectangleHitbox {\n        const size = Vec.create(width / 2, height / 2);\n\n        return new RectangleHitbox(\n            Vec.sub(pos, size),\n            Vec.add(pos, size)\n        );\n    }\n\n    override collidesWith(that: Hitbox): boolean {\n        switch (that.type) {\n            case HitboxType.Circle:\n                return Collision.rectangleCollision(this.min, this.max, that.position, that.radius);\n            case HitboxType.Rect:\n                return Collision.rectRectCollision(that.min, that.max, this.min, this.max);\n            case HitboxType.Group:\n            case HitboxType.Polygon:\n                return that.collidesWith(this);\n        }\n    }\n\n    override resolveCollision(that: Hitbox): void {\n        switch (that.type) {\n            case HitboxType.Circle: {\n                const collision = Collision.rectCircleIntersection(this.min, this.max, that.position, that.radius);\n                if (collision) {\n                    const rect = this.transform(Vec.scale(collision.dir, collision.pen));\n                    this.min = rect.min;\n                    this.max = rect.max;\n                }\n                break;\n            }\n            case HitboxType.Rect: {\n                const collision = Collision.rectRectIntersection(this.min, this.max, that.min, that.max);\n                if (collision) {\n                    const rect = this.transform(Vec.scale(collision.dir, collision.pen));\n                    this.min = rect.min;\n                    this.max = rect.max;\n                }\n                break;\n            }\n            case HitboxType.Group: {\n                for (const hitbox of that.hitboxes) {\n                    if (this.collidesWith(hitbox)) this.resolveCollision(hitbox);\n                }\n                break;\n            }\n            default:\n                this.throwUnknownSubclassError(that);\n        }\n    }\n\n    override distanceTo(that: Hitbox): CollisionRecord {\n        switch (that.type) {\n            case HitboxType.Circle:\n                return Collision.distanceBetweenRectangleCircle(this.min, this.max, that.position, that.radius);\n            case HitboxType.Rect:\n                return Collision.distanceBetweenRectangles(that.min, that.max, this.min, this.max);\n        }\n        this.throwUnknownSubclassError(that);\n    }\n\n    override clone(): RectangleHitbox {\n        return new RectangleHitbox(Vec.clone(this.min), Vec.clone(this.max));\n    }\n\n    override transform(position: Vector, scale = 1, orientation = 0 as Orientation): RectangleHitbox {\n        const rect = Geometry.transformRectangle(position, this.min, this.max, scale, orientation);\n\n        return new RectangleHitbox(rect.min, rect.max);\n    }\n\n    override scale(scale: number): void {\n        const centerX = (this.min.x + this.max.x) / 2;\n        const centerY = (this.min.y + this.max.y) / 2;\n\n        this.min = Vec.create((this.min.x - centerX) * scale + centerX, (this.min.y - centerY) * scale + centerY);\n        this.max = Vec.create((this.max.x - centerX) * scale + centerX, (this.max.y - centerY) * scale + centerY);\n    }\n\n    override intersectsLine(a: Vector, b: Vector): IntersectionResponse {\n        return Collision.lineIntersectsRect(a, b, this.min, this.max);\n    }\n\n    override randomPoint(): Vector {\n        return {\n            x: randomFloat(this.min.x, this.max.x),\n            y: randomFloat(this.min.y, this.max.y)\n        };\n    }\n\n    override toRectangle(): this {\n        return this;\n    }\n\n    override isPointInside(point: Vector): boolean {\n        return point.x > this.min.x && point.y > this.min.y && point.x < this.max.x && point.y < this.max.y;\n    }\n\n    override getCenter(): Vector {\n        return {\n            x: this.min.x + ((this.max.x - this.min.x) / 2),\n            y: this.min.y + ((this.max.y - this.min.y) / 2)\n        };\n    }\n}\n\nexport class HitboxGroup extends BaseHitbox<HitboxType.Group> {\n    override readonly type = HitboxType.Group;\n    position = Vec.create(0, 0);\n    hitboxes: Array<RectangleHitbox | CircleHitbox>;\n\n    constructor(...hitboxes: Array<RectangleHitbox | CircleHitbox>) {\n        super();\n        this.hitboxes = hitboxes;\n    }\n\n    toJSON(): HitboxJSONMapping[HitboxType.Group] {\n        return {\n            type: HitboxType.Group,\n            hitboxes: this.hitboxes.map(hitbox => hitbox.toJSON())\n        };\n    }\n\n    override collidesWith(that: Hitbox): boolean {\n        return this.hitboxes.some(hitbox => hitbox.collidesWith(that));\n    }\n\n    override resolveCollision(that: Hitbox): void {\n        that.resolveCollision(this);\n    }\n\n    override distanceTo(that: CircleHitbox | RectangleHitbox): CollisionRecord {\n        let distance = Number.MAX_VALUE;\n        let record: CollisionRecord;\n\n        for (const hitbox of this.hitboxes) {\n            let newRecord: CollisionRecord;\n\n            switch (hitbox.type) {\n                case HitboxType.Circle:\n                    switch (that.type) {\n                        case HitboxType.Circle:\n                            newRecord = Collision.distanceBetweenCircles(that.position, that.radius, hitbox.position, hitbox.radius);\n                            break;\n                        case HitboxType.Rect:\n                            newRecord = Collision.distanceBetweenRectangleCircle(that.min, that.max, hitbox.position, hitbox.radius);\n                            break;\n                    }\n                    break;\n                case HitboxType.Rect: {\n                    switch (that.type) {\n                        case HitboxType.Circle:\n                            newRecord = Collision.distanceBetweenRectangleCircle(hitbox.min, hitbox.max, that.position, that.radius);\n                            break;\n                        case HitboxType.Rect:\n                            newRecord = Collision.distanceBetweenRectangles(that.min, that.max, hitbox.min, hitbox.max);\n                    }\n                }\n            }\n            if (newRecord!.distance < distance) {\n                record = newRecord!;\n                distance = newRecord!.distance;\n            }\n        }\n\n        return record!;\n    }\n\n    override clone(): HitboxGroup {\n        return new HitboxGroup(...this.hitboxes.map(hitbox => hitbox.clone()));\n    }\n\n    override transform(position: Vector, scale?: number | undefined, orientation?: Orientation | undefined): HitboxGroup {\n        this.position = position;\n\n        return new HitboxGroup(\n            ...this.hitboxes.map(hitbox => hitbox.transform(position, scale, orientation))\n        );\n    }\n\n    override scale(scale: number): void {\n        for (const hitbox of this.hitboxes) hitbox.scale(scale);\n    }\n\n    override intersectsLine(a: Vector, b: Vector): IntersectionResponse {\n        const intersections: Array<{ readonly point: Vector, readonly normal: Vector }> = [];\n\n        // get the closest intersection point from the start of the line\n        for (const hitbox of this.hitboxes) {\n            const intersection = hitbox.intersectsLine(a, b);\n            if (intersection) intersections.push(intersection);\n        }\n\n        return intersections.sort((c, d) => Geometry.distanceSquared(c.point, a) - Geometry.distanceSquared(d.point, a))[0] ?? null;\n    }\n\n    override randomPoint(): Vector {\n        return pickRandomInArray(this.hitboxes).randomPoint();\n    }\n\n    override toRectangle(): RectangleHitbox {\n        const min = Vec.create(Number.MAX_VALUE, Number.MAX_VALUE);\n        const max = Vec.create(0, 0);\n        for (const hitbox of this.hitboxes) {\n            const toRect = hitbox.toRectangle();\n            min.x = Math.min(min.x, toRect.min.x);\n            min.y = Math.min(min.y, toRect.min.y);\n            max.x = Math.max(max.x, toRect.max.x);\n            max.y = Math.max(max.y, toRect.max.y);\n        }\n\n        return new RectangleHitbox(min, max);\n    }\n\n    override isPointInside(point: Vector): boolean {\n        for (const hitbox of this.hitboxes) {\n            if (hitbox.isPointInside(point)) return true;\n        }\n        return false;\n    }\n\n    override getCenter(): Vector {\n        return this.toRectangle().getCenter();\n    }\n}\n\nexport class PolygonHitbox extends BaseHitbox {\n    override readonly type = HitboxType.Polygon;\n    points: Vector[];\n\n    constructor(points: Vector[]) {\n        super();\n        this.points = points;\n    }\n\n    override toJSON(): HitboxJSONMapping[HitboxType.Polygon] {\n        return {\n            type: this.type,\n            points: this.points.map(point => Vec.clone(point))\n        };\n    }\n\n    override collidesWith(that: Hitbox): boolean {\n        switch (that.type) {\n            case HitboxType.Rect: {\n                if (this.isPointInside(that.min) || this.isPointInside(that.max)) return true;\n                const length = this.points.length;\n                for (let i = 0; i < length; i++) {\n                    const a = this.points[i];\n                    if (that.isPointInside(a)) return true;\n                    const b = this.points[(i + 1) % length];\n\n                    if (Collision.lineIntersectsRectTest(b, a, that.min, that.max)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n        this.throwUnknownSubclassError(that);\n    }\n\n    override resolveCollision(that: Hitbox): void {\n        this.throwUnknownSubclassError(that);\n    }\n\n    override distanceTo(that: CircleHitbox | RectangleHitbox): CollisionRecord {\n        this.throwUnknownSubclassError(that);\n    }\n\n    override clone(): PolygonHitbox {\n        return new PolygonHitbox(this.points);\n    }\n\n    override transform(position: Vector, scale: number = 1, orientation: Orientation = 0): PolygonHitbox {\n        return new PolygonHitbox(\n            this.points.map(point => Vec.scale(Vec.addAdjust(position, point, orientation), scale))\n        );\n    }\n\n    override scale(scale: number): void {\n        for (let i = 0, length = this.points.length; i < length; i++) {\n            this.points[i] = Vec.scale(this.points[i], scale);\n        }\n    }\n\n    override intersectsLine(_a: Vector, _b: Vector): IntersectionResponse {\n        throw new Error(\"Operation not supported\");\n    }\n\n    override randomPoint(): Vector {\n        const rect = this.toRectangle();\n        let point: Vector;\n\n        do {\n            point = rect.randomPoint();\n        } while (!this.isPointInside(point));\n\n        return point;\n    }\n\n    override toRectangle(): RectangleHitbox {\n        const min = Vec.create(Number.MAX_VALUE, Number.MAX_VALUE);\n        const max = Vec.create(0, 0);\n        for (const point of this.points) {\n            min.x = Math.min(min.x, point.x);\n            min.y = Math.min(min.y, point.y);\n            max.x = Math.max(max.x, point.x);\n            max.y = Math.max(max.y, point.y);\n        }\n\n        return new RectangleHitbox(min, max);\n    }\n\n    override isPointInside(point: Vector): boolean {\n        const { x, y } = point;\n        let inside = false;\n        const count = this.points.length;\n        // take first and last\n        // then take second and second last\n        // so on\n        for (let i = 0, j = count - 1; i < count; j = i++) {\n            const { x: xi, y: yi } = this.points[i];\n            const { x: xj, y: yj } = this.points[j];\n\n            if ((yi > y) !== (yj > y) && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n\n    override getCenter(): Vector {\n        return this.toRectangle().getCenter();\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1260, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1265, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/vendor/suroi/common/src/utils/math.ts"],"sourcesContent":["import { type ObstacleDefinition } from \"../definitions/obstacles\";\nimport { type Orientation } from \"../typings\";\nimport { RectangleHitbox } from \"./hitbox\";\nimport { ObstacleSpecialRoles } from \"./objectDefinitions\";\nimport { Vec, type Vector } from \"./vector\";\n\nexport const Angle = Object.freeze({\n    /**\n     * Draws a line between two points and returns that line's angle\n     * @param a The first point, used as the head of the vector\n     * @param b The second point, used as the tail of the vector\n     * @returns The angle, in radians, of the line going from b to a\n     */\n    betweenPoints(a: Vector, b: Vector): number {\n        return Math.atan2(a.y - b.y, a.x - b.x);\n    },\n    /**\n     * Normalize an angle to a value between -π and π\n     * @param radians The angle, in radians\n     */\n    normalize(radians: number): number {\n        const π = Math.PI;\n        return Numeric.absMod(radians - π, 2 * π) - π;\n    },\n    /**\n     * Find the smallest difference between two angles\n     * (the difference between 10º and 350º can be either -340º or 20º—chances are, you're looking for the latter)\n     * @param start The initial angle, in radians\n     * @param end The final angle, in radians\n     */\n    minimize(start: number, end: number): number {\n        const π = Math.PI;\n        return Numeric.absMod(end - start + π, 2 * π) - π;\n    },\n    /**\n     * Converts degrees to radians\n     * @param degrees An angle in degrees\n     * @return The angle in radians\n     */\n    degreesToRadians(degrees: number): number {\n        return degrees * (Math.PI / 180);\n    },\n    /**\n     * Converts radians to degrees\n     * @param radians An angle in radians\n     * @return The angle in degrees\n     */\n    radiansToDegrees(radians: number): number {\n        return (radians / Math.PI) * 180;\n    },\n    orientationToRotation(orientation: number): number {\n        return -this.normalize(orientation * (Math.PI / 2));\n    }\n});\n\nexport const Numeric = Object.freeze({\n    /**\n     * Works like regular modulo, but negative numbers cycle back around: hence,\n     * `-1 % 4` gives `3` and not `-1`\n     * @param a The dividend\n     * @param n The divisor\n     */\n    absMod(a: number, n: number): number {\n        return a >= 0\n            ? a % n\n            : (a % n + n) % n;\n    },\n    /**\n     * Interpolate between two values\n     * @param start The start value\n     * @param end The end value\n     * @param interpFactor The interpolation factor\n     * @returns A number corresponding to the linear interpolation between `a` and `b` at factor `interpFactor`\n     */\n    lerp(start: number, end: number, interpFactor: number): number {\n        return start * (1 - interpFactor) + end * interpFactor;\n    },\n    /**\n     * Conform a number to specified bounds\n     * @param value The number to conform\n     * @param min The minimum value the number can be\n     * @param max The maximum value the number can be\n     */\n    clamp(value: number, min: number, max: number): number {\n        return value < max ? value > min ? value : min : max;\n    },\n    /**\n     * Snaps a value to either bounds, unless it's precisely halfway between them\n     * @param value The value to snap\n     * @param min The smallest snap value\n     * @param max The largest snap value\n     * @returns Either the `min`, `max` or the original value if it happens to be\n     * exactly halfway between `min` and `max`\n     */\n    clampToBound(value: number, min: number, max: number): number {\n        const mid = (min + max) / 2;\n        switch (true) {\n            case value >= max:\n            case value > mid:\n                return max;\n            case value <= min:\n            case value < mid:\n                return min;\n            default:\n                return value;\n        }\n    },\n    /**\n     * Add two orientations\n     * @param n1 The first orientation\n     * @param n2 The second orientation\n     * @return The sum of the two `Orientation`s\n     */\n    addOrientations(n1: Orientation, n2: Orientation): Orientation {\n        return (n1 + n2) % 4 as Orientation;\n    }\n});\n\nexport const Geometry = Object.freeze({\n    /**\n     * Get the distance between two points\n     * @param a The first point\n     * @param b The second point\n     */\n    distance(a: Vector, b: Vector): number {\n        return Math.sqrt(this.distanceSquared(a, b));\n    },\n    /**\n     * Get the distance between two points squared\n     * @param a The first point\n     * @param b The second point\n     */\n    distanceSquared(a: Vector, b: Vector): number {\n        return (b.x - a.x) ** 2 + (b.y - a.y) ** 2;\n    },\n    /**\n     * Returns the area of a triangle whose vertices are the three vectors passed in\n     * @param a The first vertex\n     * @param b The second vertex\n     * @param c The third vertex\n     * @returns The area of the triangle formed by the three provided vectors\n     */\n    signedAreaTri(a: Vector, b: Vector, c: Vector): number {\n        return (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);\n    },\n    /**\n     * Transform a rectangle by a given position and orientation\n     * @param pos The position to transform the rectangle by\n     * @param min The rectangle min `Vector`\n     * @param max The rectangle max `Vector`\n     * @param scale The rectangle's scale\n     * @param orientation The orientation to rotate it\n     * @return A new Rectangle transformed by the given position and orientation\n     */\n    transformRectangle(pos: Vector, min: Vector, max: Vector, scale: number, orientation: Orientation): { readonly min: Vector, readonly max: Vector } {\n        min = Vec.scale(min, scale);\n        max = Vec.scale(max, scale);\n        if (orientation !== 0) {\n            const minX = min.x; const minY = min.y;\n            const maxX = max.x; const maxY = max.y;\n            switch (orientation) {\n                case 1:\n                    min = Vec.create(maxX, minY);\n                    max = Vec.create(minX, maxY);\n                    break;\n                case 2:\n                    min = Vec.create(maxX, maxY);\n                    max = Vec.create(minX, minY);\n                    break;\n                case 3:\n                    min = Vec.create(minX, maxY);\n                    max = Vec.create(maxX, minY);\n                    break;\n            }\n        }\n        return {\n            min: Vec.addAdjust(pos, min, orientation),\n            max: Vec.addAdjust(pos, max, orientation)\n        };\n    }\n});\n\nexport const Collision = Object.freeze({\n    /**\n     * Check if two circles colliding\n     * @param centerA The center of the first circle\n     * @param radiusA The radius of the first circle\n     * @param centerB The center of the second circle\n     * @param radiusB The radius of the second circle\n     */\n    circleCollision(centerA: Vector, radiusA: number, centerB: Vector, radiusB: number): boolean {\n        const a = radiusA + radiusB;\n        const x = centerA.x - centerB.x;\n        const y = centerA.y - centerB.y;\n\n        return a * a > x * x + y * y;\n    },\n    /**\n     * Check if a circle and a rectangle are colliding\n     * @param min The min Vector of the rectangle\n     * @param max The max vector of the rectangle\n     * @param pos The center of the circle\n     * @param rad The radius of the circle\n     */\n    rectangleCollision(min: Vector, max: Vector, pos: Vector, rad: number): boolean {\n        const cpt = {\n            x: Numeric.clamp(pos.x, min.x, max.x),\n            y: Numeric.clamp(pos.y, min.y, max.y)\n        };\n\n        const distX = pos.x - cpt.x; const distY = pos.y - cpt.y;\n        const distSquared = distX * distX + distY * distY;\n\n        return (distSquared < rad * rad) || (pos.x >= min.x && pos.x <= max.x && pos.y >= min.y && pos.y <= max.y);\n    },\n    /**\n     * Check if two rectangles collide\n     * @param min1 The min `Vector` of the first rectangle\n     * @param max1 The max `Vector` of the first rectangle\n     * @param min2 The min `Vector` of the second rectangle\n     * @param max2 The max `Vector` of the second rectangle\n     * @returns `true` if the two rectangles collide, `false` if not\n     */\n    rectRectCollision(min1: Vector, max1: Vector, min2: Vector, max2: Vector): boolean {\n        return min2.x < max1.x && min2.y < max1.y && min1.x < max2.x && min1.y < max2.y;\n    },\n    /**\n     * Determines the distance between two circles\n     * @param centerA The center of the first circle\n     * @param radiusA The radius of the first circle\n     * @param centerB The center of the second circle\n     * @param radiusB The radius of the second circle\n     * @returns An object containing a boolean indicating whether the two circles are colliding and a number indicating the distance between them\n     */\n    distanceBetweenCircles(centerA: Vector, radiusA: number, centerB: Vector, radiusB: number): CollisionRecord {\n        const a = radiusA + radiusB;\n        const x = centerA.x - centerB.x;\n        const y = centerA.y - centerB.y;\n        const a2 = a * a;\n        const xy = x * x + y * y;\n        return { collided: a2 > xy, distance: a2 - xy };\n    },\n    /**\n     * Determines the distance between a circle and a rectangle\n     * @param min The min `Vector` of the rectangle\n     * @param max The max `Vector` of the rectangle\n     * @param circlePos The center of the circle\n     * @param circleRad The radius of the circle\n     * @returns An object containing a boolean indicating whether the two shapes are colliding and a number indicating the distance between them\n     */\n    distanceBetweenRectangleCircle(min: Vector, max: Vector, circlePos: Vector, circleRad: number): CollisionRecord {\n        const distX = Math.max(min.x, Math.min(max.x, circlePos.x)) - circlePos.x;\n        const distY = Math.max(min.y, Math.min(max.y, circlePos.y)) - circlePos.y;\n        const radSquared = circleRad * circleRad;\n        const distSquared = distX * distX + distY * distY;\n        return { collided: distSquared < radSquared, distance: distSquared - radSquared };\n    },\n    /**\n     * Determines the distance between two rectangles\n     * @param min1 The min `Vector` of the first rectangle\n     * @param max1 The max `Vector` of the first rectangle\n     * @param min2 The min `Vector` of the second rectangle\n     * @param max2 The max `Vector` of the second rectangle\n     * @returns An object containing a boolean indicating whether the two rectangles are colliding and a number indicating the distance between them\n     */\n    distanceBetweenRectangles(min1: Vector, max1: Vector, min2: Vector, max2: Vector): CollisionRecord {\n        const distX = Math.max(min1.x, Math.min(max1.x, min2.x, max2.x)) - Math.min(min1.x, Math.max(max1.x, min2.x, max2.x));\n        const distY = Math.max(min1.y, Math.min(max1.y, min2.y, max2.y)) - Math.min(min1.y, Math.max(max1.y, min2.y, max2.y));\n\n        // If distX or distY is negative, the rectangles are overlapping in that dimension, and the distance is 0\n        if (distX < 0 || distY < 0) {\n            return { collided: true, distance: 0 };\n        }\n\n        // Calculate the squared distance between the rectangles\n        const distSquared = distX * distX + distY * distY;\n        return { collided: false, distance: distSquared };\n    },\n    /**\n     * Determines where a line intersects another line\n     * @param startA The start of the first line\n     * @param endA The end of the first line\n     * @param startB The start of the second line\n     * @param endB The end of the second line\n     * @return The intersection position and null if no such intersection exists\n     */\n    lineIntersectsLine(startA: Vector, endA: Vector, startB: Vector, endB: Vector): Vector | null {\n        const x1 = Geometry.signedAreaTri(startA, endA, endB);\n        const x2 = Geometry.signedAreaTri(startA, endA, startB);\n\n        if (x1 !== 0.0 && x2 !== 0.0 && x1 * x2 < 0.0) {\n            const x3 = Geometry.signedAreaTri(startB, endB, startA);\n            const x4 = x3 + x2 - x1;\n\n            if (x3 * x4 < 0.0) {\n                return Vec.add(\n                    startA,\n                    Vec.scale(\n                        Vec.sub(endA, startA),\n                        x3 / (x3 - x4)\n                    )\n                );\n            }\n        }\n\n        return null;\n    },\n    /**\n     * Determines where a line intersects a circle\n     * @param s0 The start of the line\n     * @param s1 The end of the line\n     * @param pos The position of the circle\n     * @param rad The radius of the circle\n     * @return An intersection response with the intersection position and normal `Vector`s, or `null` if they don't intersect\n     */\n    lineIntersectsCircle(s0: Vector, s1: Vector, pos: Vector, rad: number): IntersectionResponse {\n        let d = Vec.sub(s1, s0);\n        const len = Math.max(Vec.length(d), 0.000001);\n        d = Vec.normalizeSafe(d);\n\n        const m = Vec.sub(s0, pos);\n        const b = Vec.dotProduct(m, d);\n        const c = Vec.dotProduct(m, m) - rad * rad;\n\n        if (c > 0 && b > 0) return null;\n\n        const discSq = b * b - c;\n        if (discSq < 0) return null;\n\n        const disc = Math.sqrt(discSq);\n        const t = -b < disc\n            ? disc - b\n            : -b - disc;\n\n        if (t <= len) {\n            const point = Vec.add(s0, Vec.scale(d, t));\n            return {\n                point,\n                normal: Vec.normalize(Vec.sub(point, pos))\n            };\n        }\n\n        return null;\n    },\n    /**\n     * Determines where a line intersects a rectangle\n     * @param s0 The start of the line\n     * @param s1 The end of the line\n     * @param min The min Vector of the rectangle\n     * @param max The max Vector of the rectangle\n     * @return An intersection response with the intersection position and normal `Vector`s, or `null` if they don't intersect\n     */\n    lineIntersectsRect(s0: Vector, s1: Vector, min: Vector, max: Vector): IntersectionResponse {\n        let tmin = 0;\n        let tmax = Number.MAX_VALUE;\n\n        const eps = 1e-5;\n        const r = s0;\n\n        let d = Vec.sub(s1, s0);\n        const dist = Vec.length(d);\n        d = Vec.normalizeSafe(d);\n\n        let absDx = Math.abs(d.x);\n        let absDy = Math.abs(d.y);\n\n        if (absDx < eps) {\n            d.x = eps * 2.0;\n            absDx = d.x;\n        }\n\n        if (absDy < eps) {\n            d.y = eps * 2.0;\n            absDy = d.y;\n        }\n\n        if (absDx > eps) {\n            const tx1 = (min.x - r.x) / d.x;\n            const tx2 = (max.x - r.x) / d.x;\n\n            tmin = Math.max(tmin, Math.min(tx1, tx2));\n            tmax = Math.min(tmax, Math.max(tx1, tx2));\n\n            if (tmin > tmax) return null;\n        }\n\n        if (absDy > eps) {\n            const ty1 = (min.y - r.y) / d.y;\n            const ty2 = (max.y - r.y) / d.y;\n\n            tmin = Math.max(tmin, Math.min(ty1, ty2));\n            tmax = Math.min(tmax, Math.max(ty1, ty2));\n\n            if (tmin > tmax) return null;\n        }\n\n        if (tmin > dist) return null;\n\n        // Hit\n        const p = Vec.add(s0, Vec.scale(d, tmin));\n\n        // Intersection normal\n        const c = Vec.add(min, Vec.scale(Vec.sub(max, min), 0.5));\n        const p0 = Vec.sub(p, c);\n        const d0 = Vec.scale(Vec.sub(min, max), 0.5);\n\n        const x = p0.x / Math.abs(d0.x) * 1.001;\n        const y = p0.y / Math.abs(d0.y) * 1.001;\n\n        return {\n            point: p,\n            normal: Vec.normalizeSafe(\n                Vec.create(Math.trunc(x), Math.trunc(y)),\n                Vec.create(1, 0)\n            )\n        };\n    },\n    /**\n     * Checks if a line intersects a rectangle\n     * @param s0 The start of the line\n     * @param s1 The end of the line\n     * @param min The min Vector of the rectangle\n     * @param max The max Vector of the rectangle\n     * @return `true` if the line intersects, `false` otherwise\n     */\n    lineIntersectsRectTest(s0: Vector, s1: Vector, min: Vector, max: Vector): boolean {\n        let tmin = 0;\n        let tmax = Number.MAX_VALUE;\n\n        const eps = 1e-5;\n        let d = Vec.sub(s1, s0);\n        const dist = Vec.length(d);\n        d = Vec.normalizeSafe(d);\n\n        let absDx = Math.abs(d.x);\n        let absDy = Math.abs(d.y);\n\n        if (absDx < eps) {\n            d.x = eps * 2.0;\n            absDx = d.x;\n        }\n\n        if (absDy < eps) {\n            d.y = eps * 2.0;\n            absDy = d.y;\n        }\n\n        if (absDx > eps) {\n            const tx1 = (min.x - s0.x) / d.x;\n            const tx2 = (max.x - s0.x) / d.x;\n\n            tmin = Math.max(tmin, Math.min(tx1, tx2));\n            tmax = Math.min(tmax, Math.max(tx1, tx2));\n\n            if (tmin > tmax) return false;\n        }\n\n        if (absDy > eps) {\n            const ty1 = (min.y - s0.y) / d.y;\n            const ty2 = (max.y - s0.y) / d.y;\n\n            tmin = Math.max(tmin, Math.min(ty1, ty2));\n            tmax = Math.min(tmax, Math.max(ty1, ty2));\n\n            if (tmin > tmax) return false;\n        }\n\n        return tmin <= dist;\n    },\n    circleCircleIntersection(centerA: Vector, radiusA: number, centerB: Vector, radiusB: number): CollisionResponse {\n        const r = radiusA + radiusB;\n        const toP1 = Vec.sub(centerB, centerA);\n        const distSqr = Vec.squaredLength(toP1);\n\n        return distSqr < r * r\n            ? {\n                dir: Vec.normalizeSafe(toP1),\n                pen: r - Math.sqrt(distSqr)\n            }\n            : null;\n    },\n    rectCircleIntersection(min: Vector, max: Vector, pos: Vector, radius: number): CollisionResponse {\n        if (\n            min.x <= pos.x && pos.x <= max.x &&\n            min.y <= pos.y && pos.y <= max.y\n        ) {\n            // circle center inside rectangle\n\n            const halfDimension = Vec.scale(Vec.sub(max, min), 0.5);\n            const p = Vec.sub(pos, Vec.add(min, halfDimension));\n            const xp = Math.abs(p.x) - halfDimension.x - radius;\n            const yp = Math.abs(p.y) - halfDimension.y - radius;\n\n            return xp > yp\n                ? {\n                    dir: Vec.create(\n                        p.x > 0 ? 1 : -1,\n                        0\n                    ),\n                    pen: -xp\n                }\n                : {\n                    dir: Vec.create(\n                        0,\n                        p.y > 0 ? 1 : -1\n                    ),\n                    pen: -yp\n                };\n        }\n\n        const dir = Vec.sub(\n            Vec.create(\n                Numeric.clamp(pos.x, min.x, max.x),\n                Numeric.clamp(pos.y, min.y, max.y)\n            ),\n            pos\n        );\n        const dstSqr = Vec.squaredLength(dir);\n\n        if (dstSqr < radius * radius) {\n            const dst = Math.sqrt(dstSqr);\n            return {\n                dir: Vec.normalizeSafe(dir),\n                pen: radius - dst\n            };\n        }\n\n        return null;\n    },\n    distanceToLine(p: Vector, a: Vector, b: Vector): number {\n        const ab = Vec.sub(b, a);\n\n        return Vec.squaredLength(\n            Vec.sub(\n                Vec.add(\n                    a,\n                    Vec.scale(\n                        ab,\n                        Numeric.clamp(\n                            Vec.dotProduct(Vec.sub(p, a), ab) / Vec.dotProduct(ab, ab),\n                            0, 1\n                        )\n                    )\n                ),\n                p\n            )\n        );\n    },\n    /**\n     * Source\n     * @link http://ahamnett.blogspot.com/2012/06/raypolygon-intersections.html\n     */\n    rayIntersectsLine(origin: Vector, direction: Vector, lineA: Vector, lineB: Vector): number | null {\n        const segment = Vec.sub(lineB, lineA);\n        const segmentPerp = Vec.create(segment.y, -segment.x);\n        const perpDotDir = Vec.dotProduct(direction, segmentPerp);\n\n        // If lines are parallel, no intersection\n        if (Math.abs(perpDotDir) <= 1e-7) return null;\n\n        const d = Vec.sub(lineA, origin);\n        const distanceAlongRay = Vec.dotProduct(segmentPerp, d) / perpDotDir;\n        const distanceAlongLine = Vec.dotProduct(Vec.create(direction.y, -direction.x), d) / perpDotDir;\n\n        // If t is positive and s lies within the line it intersects; returns t\n        return distanceAlongRay >= 0 && distanceAlongLine >= 0 && distanceAlongLine <= 1 ? distanceAlongRay : null;\n    },\n    rayIntersectsPolygon(origin: Vector, direction: Vector, polygon: Vector[]): number | null {\n        let t = Number.MAX_VALUE;\n\n        let intersected = false;\n        for (\n            let i = 0, length = polygon.length, j = length - 1;\n            i < length;\n            j = i++\n        ) {\n            const dist = Collision.rayIntersectsLine(origin, direction, polygon[j], polygon[i]);\n\n            if (dist !== null && dist < t) {\n                intersected = true;\n                t = dist;\n            }\n        }\n\n        // Returns closest intersection\n        return intersected ? t : null;\n    },\n    rectRectIntersection(min0: Vector, max0: Vector, min1: Vector, max1: Vector): CollisionResponse {\n        const e0 = Vec.scale(Vec.sub(max0, min0), 0.5);\n        const e1 = Vec.scale(Vec.sub(max1, min1), 0.5);\n        const n = Vec.sub(\n            Vec.add(min1, e1),\n            Vec.add(min0, e0)\n        );\n        const xo = e0.x + e1.x - Math.abs(n.x);\n        const yo = e0.y + e1.y - Math.abs(n.y);\n\n        return xo > 0.0 && yo > 0.0\n            ? xo > yo\n                ? {\n                    dir: Vec.create(Math.sign(n.x), 0),\n                    pen: xo\n                }\n                : {\n                    dir: Vec.create(0, Math.sign(n.y)),\n                    pen: yo\n                }\n            : null;\n    }\n});\n\nexport interface CollisionRecord {\n    readonly collided: boolean\n    readonly distance: number\n}\n\nexport type IntersectionResponse = {\n    readonly point: Vector\n    readonly normal: Vector\n} | null;\n\nexport type CollisionResponse = {\n    readonly dir: Vector\n    readonly pen: number\n} | null;\n\nexport function calculateDoorHitboxes<\n    // tf are you talking about\n    // eslint-disable-next-line space-before-function-paren\n    U extends (ObstacleDefinition & { readonly role: ObstacleSpecialRoles.Door })[\"operationStyle\"]\n>(\n    definition: ObstacleDefinition & { readonly role: ObstacleSpecialRoles.Door, readonly operationStyle?: U },\n    position: Vector,\n    rotation: Orientation\n): U extends \"slide\"\n        ? { readonly openHitbox: RectangleHitbox }\n        : { readonly openHitbox: RectangleHitbox, readonly openAltHitbox: RectangleHitbox } {\n    if (!(definition.hitbox instanceof RectangleHitbox) || definition.role !== ObstacleSpecialRoles.Door) {\n        throw new Error(\"Unable to calculate hitboxes for door: Not a door or hitbox is non-rectangular\");\n    }\n\n    type Swivel = typeof definition & { readonly operationStyle: \"swivel\" };\n    type Slide = typeof definition & { readonly operationStyle: \"slide\" };\n    type Return = U extends \"slide\"\n        ? { readonly openHitbox: RectangleHitbox }\n        : { readonly openHitbox: RectangleHitbox, readonly openAltHitbox: RectangleHitbox };\n\n    switch (definition.operationStyle) {\n        case \"slide\": {\n            const openHitbox = Geometry.transformRectangle(\n                Vec.addAdjust(position, Vec.create((definition.hitbox.min.x - definition.hitbox.max.x) * ((definition as Slide).slideFactor ?? 1), 0), rotation),\n                definition.hitbox.min,\n                definition.hitbox.max,\n                1,\n                rotation\n            );\n\n            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n            return {\n                openHitbox: new RectangleHitbox(openHitbox.min, openHitbox.max)\n            } as Return;\n        }\n        case \"swivel\":\n        default: {\n            const openRectangle = Geometry.transformRectangle(\n                Vec.addAdjust(position, Vec.add((definition as Swivel).hingeOffset, Vec.create(-(definition as Swivel).hingeOffset.y, (definition as Swivel).hingeOffset.x)), rotation),\n                definition.hitbox.min,\n                definition.hitbox.max,\n                1,\n                Numeric.absMod(rotation + 1, 4) as Orientation\n            );\n            const openAltRectangle = Geometry.transformRectangle(\n                Vec.addAdjust(position, Vec.add((definition as Swivel).hingeOffset, Vec.create((definition as Swivel).hingeOffset.y, -(definition as Swivel).hingeOffset.x)), rotation),\n                definition.hitbox.min,\n                definition.hitbox.max,\n                1,\n                Numeric.absMod(rotation - 1, 4) as Orientation\n            );\n\n            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n            return {\n                openHitbox: new RectangleHitbox(openRectangle.min, openRectangle.max),\n                openAltHitbox: new RectangleHitbox(openAltRectangle.min, openAltRectangle.max)\n            } as Return;\n        }\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAMO,MAAM,QAAQ,OAAO,MAAM,CAAC;IAC/B;;;;;KAKC,GACD,eAAc,CAAS,EAAE,CAAS;QAC9B,OAAO,KAAK,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC,GAAG,EAAE,CAAC;IAC1C;IACA;;;KAGC,GACD,WAAU,OAAe;QACrB,MAAM,IAAI,KAAK,EAAE;QACjB,OAAO,QAAQ,MAAM,CAAC,UAAU,GAAG,IAAI,KAAK;IAChD;IACA;;;;;KAKC,GACD,UAAS,KAAa,EAAE,GAAW;QAC/B,MAAM,IAAI,KAAK,EAAE;QACjB,OAAO,QAAQ,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAI,KAAK;IACpD;IACA;;;;KAIC,GACD,kBAAiB,OAAe;QAC5B,OAAO,UAAU,CAAC,KAAK,EAAE,GAAG,GAAG;IACnC;IACA;;;;KAIC,GACD,kBAAiB,OAAe;QAC5B,OAAO,AAAC,UAAU,KAAK,EAAE,GAAI;IACjC;IACA,uBAAsB,WAAmB;QACrC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,KAAK,EAAE,GAAG,CAAC;IACrD;AACJ;AAEO,MAAM,UAAU,OAAO,MAAM,CAAC;IACjC;;;;;KAKC,GACD,QAAO,CAAS,EAAE,CAAS;QACvB,OAAO,KAAK,IACN,IAAI,IACJ,CAAC,IAAI,IAAI,CAAC,IAAI;IACxB;IACA;;;;;;KAMC,GACD,MAAK,KAAa,EAAE,GAAW,EAAE,YAAoB;QACjD,OAAO,QAAQ,CAAC,IAAI,YAAY,IAAI,MAAM;IAC9C;IACA;;;;;KAKC,GACD,OAAM,KAAa,EAAE,GAAW,EAAE,GAAW;QACzC,OAAO,QAAQ,MAAM,QAAQ,MAAM,QAAQ,MAAM;IACrD;IACA;;;;;;;KAOC,GACD,cAAa,KAAa,EAAE,GAAW,EAAE,GAAW;QAChD,MAAM,MAAM,CAAC,MAAM,GAAG,IAAI;QAC1B,OAAQ;YACJ,KAAK,SAAS;YACd,KAAK,QAAQ;gBACT,OAAO;YACX,KAAK,SAAS;YACd,KAAK,QAAQ;gBACT,OAAO;YACX;gBACI,OAAO;QACf;IACJ;IACA;;;;;KAKC,GACD,iBAAgB,EAAe,EAAE,EAAe;QAC5C,OAAO,CAAC,KAAK,EAAE,IAAI;IACvB;AACJ;AAEO,MAAM,WAAW,OAAO,MAAM,CAAC;IAClC;;;;KAIC,GACD,UAAS,CAAS,EAAE,CAAS;QACzB,OAAO,KAAK,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,GAAG;IAC7C;IACA;;;;KAIC,GACD,iBAAgB,CAAS,EAAE,CAAS;QAChC,OAAO,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,KAAK,IAAI,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,KAAK;IAC7C;IACA;;;;;;KAMC,GACD,eAAc,CAAS,EAAE,CAAS,EAAE,CAAS;QACzC,OAAO,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC;IAC/D;IACA;;;;;;;;KAQC,GACD,oBAAmB,GAAW,EAAE,GAAW,EAAE,GAAW,EAAE,KAAa,EAAE,WAAwB;QAC7F,MAAM,8JAAI,KAAK,CAAC,KAAK;QACrB,MAAM,8JAAI,KAAK,CAAC,KAAK;QACrB,IAAI,gBAAgB,GAAG;YACnB,MAAM,OAAO,IAAI,CAAC;YAAE,MAAM,OAAO,IAAI,CAAC;YACtC,MAAM,OAAO,IAAI,CAAC;YAAE,MAAM,OAAO,IAAI,CAAC;YACtC,OAAQ;gBACJ,KAAK;oBACD,MAAM,8JAAI,MAAM,CAAC,MAAM;oBACvB,MAAM,8JAAI,MAAM,CAAC,MAAM;oBACvB;gBACJ,KAAK;oBACD,MAAM,8JAAI,MAAM,CAAC,MAAM;oBACvB,MAAM,8JAAI,MAAM,CAAC,MAAM;oBACvB;gBACJ,KAAK;oBACD,MAAM,8JAAI,MAAM,CAAC,MAAM;oBACvB,MAAM,8JAAI,MAAM,CAAC,MAAM;oBACvB;YACR;QACJ;QACA,OAAO;YACH,KAAK,8JAAI,SAAS,CAAC,KAAK,KAAK;YAC7B,KAAK,8JAAI,SAAS,CAAC,KAAK,KAAK;QACjC;IACJ;AACJ;AAEO,MAAM,YAAY,OAAO,MAAM,CAAC;IACnC;;;;;;KAMC,GACD,iBAAgB,OAAe,EAAE,OAAe,EAAE,OAAe,EAAE,OAAe;QAC9E,MAAM,IAAI,UAAU;QACpB,MAAM,IAAI,QAAQ,CAAC,GAAG,QAAQ,CAAC;QAC/B,MAAM,IAAI,QAAQ,CAAC,GAAG,QAAQ,CAAC;QAE/B,OAAO,IAAI,IAAI,IAAI,IAAI,IAAI;IAC/B;IACA;;;;;;KAMC,GACD,oBAAmB,GAAW,EAAE,GAAW,EAAE,GAAW,EAAE,GAAW;QACjE,MAAM,MAAM;YACR,GAAG,QAAQ,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC;YACpC,GAAG,QAAQ,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC;QACxC;QAEA,MAAM,QAAQ,IAAI,CAAC,GAAG,IAAI,CAAC;QAAE,MAAM,QAAQ,IAAI,CAAC,GAAG,IAAI,CAAC;QACxD,MAAM,cAAc,QAAQ,QAAQ,QAAQ;QAE5C,OAAO,AAAC,cAAc,MAAM,OAAS,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC;IAC7G;IACA;;;;;;;KAOC,GACD,mBAAkB,IAAY,EAAE,IAAY,EAAE,IAAY,EAAE,IAAY;QACpE,OAAO,KAAK,CAAC,GAAG,KAAK,CAAC,IAAI,KAAK,CAAC,GAAG,KAAK,CAAC,IAAI,KAAK,CAAC,GAAG,KAAK,CAAC,IAAI,KAAK,CAAC,GAAG,KAAK,CAAC;IACnF;IACA;;;;;;;KAOC,GACD,wBAAuB,OAAe,EAAE,OAAe,EAAE,OAAe,EAAE,OAAe;QACrF,MAAM,IAAI,UAAU;QACpB,MAAM,IAAI,QAAQ,CAAC,GAAG,QAAQ,CAAC;QAC/B,MAAM,IAAI,QAAQ,CAAC,GAAG,QAAQ,CAAC;QAC/B,MAAM,KAAK,IAAI;QACf,MAAM,KAAK,IAAI,IAAI,IAAI;QACvB,OAAO;YAAE,UAAU,KAAK;YAAI,UAAU,KAAK;QAAG;IAClD;IACA;;;;;;;KAOC,GACD,gCAA+B,GAAW,EAAE,GAAW,EAAE,SAAiB,EAAE,SAAiB;QACzF,MAAM,QAAQ,KAAK,GAAG,CAAC,IAAI,CAAC,EAAE,KAAK,GAAG,CAAC,IAAI,CAAC,EAAE,UAAU,CAAC,KAAK,UAAU,CAAC;QACzE,MAAM,QAAQ,KAAK,GAAG,CAAC,IAAI,CAAC,EAAE,KAAK,GAAG,CAAC,IAAI,CAAC,EAAE,UAAU,CAAC,KAAK,UAAU,CAAC;QACzE,MAAM,aAAa,YAAY;QAC/B,MAAM,cAAc,QAAQ,QAAQ,QAAQ;QAC5C,OAAO;YAAE,UAAU,cAAc;YAAY,UAAU,cAAc;QAAW;IACpF;IACA;;;;;;;KAOC,GACD,2BAA0B,IAAY,EAAE,IAAY,EAAE,IAAY,EAAE,IAAY;QAC5E,MAAM,QAAQ,KAAK,GAAG,CAAC,KAAK,CAAC,EAAE,KAAK,GAAG,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,KAAK,KAAK,GAAG,CAAC,KAAK,CAAC,EAAE,KAAK,GAAG,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC;QACnH,MAAM,QAAQ,KAAK,GAAG,CAAC,KAAK,CAAC,EAAE,KAAK,GAAG,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,KAAK,KAAK,GAAG,CAAC,KAAK,CAAC,EAAE,KAAK,GAAG,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC;QAEnH,yGAAyG;QACzG,IAAI,QAAQ,KAAK,QAAQ,GAAG;YACxB,OAAO;gBAAE,UAAU;gBAAM,UAAU;YAAE;QACzC;QAEA,wDAAwD;QACxD,MAAM,cAAc,QAAQ,QAAQ,QAAQ;QAC5C,OAAO;YAAE,UAAU;YAAO,UAAU;QAAY;IACpD;IACA;;;;;;;KAOC,GACD,oBAAmB,MAAc,EAAE,IAAY,EAAE,MAAc,EAAE,IAAY;QACzE,MAAM,KAAK,SAAS,aAAa,CAAC,QAAQ,MAAM;QAChD,MAAM,KAAK,SAAS,aAAa,CAAC,QAAQ,MAAM;QAEhD,IAAI,OAAO,OAAO,OAAO,OAAO,KAAK,KAAK,KAAK;YAC3C,MAAM,KAAK,SAAS,aAAa,CAAC,QAAQ,MAAM;YAChD,MAAM,KAAK,KAAK,KAAK;YAErB,IAAI,KAAK,KAAK,KAAK;gBACf,OAAO,8JAAI,GAAG,CACV,QACA,8JAAI,KAAK,CACL,8JAAI,GAAG,CAAC,MAAM,SACd,KAAK,CAAC,KAAK,EAAE;YAGzB;QACJ;QAEA,OAAO;IACX;IACA;;;;;;;KAOC,GACD,sBAAqB,EAAU,EAAE,EAAU,EAAE,GAAW,EAAE,GAAW;QACjE,IAAI,IAAI,8JAAI,GAAG,CAAC,IAAI;QACpB,MAAM,MAAM,KAAK,GAAG,CAAC,8JAAI,MAAM,CAAC,IAAI;QACpC,IAAI,8JAAI,aAAa,CAAC;QAEtB,MAAM,IAAI,8JAAI,GAAG,CAAC,IAAI;QACtB,MAAM,IAAI,8JAAI,UAAU,CAAC,GAAG;QAC5B,MAAM,IAAI,8JAAI,UAAU,CAAC,GAAG,KAAK,MAAM;QAEvC,IAAI,IAAI,KAAK,IAAI,GAAG,OAAO;QAE3B,MAAM,SAAS,IAAI,IAAI;QACvB,IAAI,SAAS,GAAG,OAAO;QAEvB,MAAM,OAAO,KAAK,IAAI,CAAC;QACvB,MAAM,IAAI,CAAC,IAAI,OACT,OAAO,IACP,CAAC,IAAI;QAEX,IAAI,KAAK,KAAK;YACV,MAAM,QAAQ,8JAAI,GAAG,CAAC,IAAI,8JAAI,KAAK,CAAC,GAAG;YACvC,OAAO;gBACH;gBACA,QAAQ,8JAAI,SAAS,CAAC,8JAAI,GAAG,CAAC,OAAO;YACzC;QACJ;QAEA,OAAO;IACX;IACA;;;;;;;KAOC,GACD,oBAAmB,EAAU,EAAE,EAAU,EAAE,GAAW,EAAE,GAAW;QAC/D,IAAI,OAAO;QACX,IAAI,OAAO,OAAO,SAAS;QAE3B,MAAM,MAAM;QACZ,MAAM,IAAI;QAEV,IAAI,IAAI,8JAAI,GAAG,CAAC,IAAI;QACpB,MAAM,OAAO,8JAAI,MAAM,CAAC;QACxB,IAAI,8JAAI,aAAa,CAAC;QAEtB,IAAI,QAAQ,KAAK,GAAG,CAAC,EAAE,CAAC;QACxB,IAAI,QAAQ,KAAK,GAAG,CAAC,EAAE,CAAC;QAExB,IAAI,QAAQ,KAAK;YACb,EAAE,CAAC,GAAG,MAAM;YACZ,QAAQ,EAAE,CAAC;QACf;QAEA,IAAI,QAAQ,KAAK;YACb,EAAE,CAAC,GAAG,MAAM;YACZ,QAAQ,EAAE,CAAC;QACf;QAEA,IAAI,QAAQ,KAAK;YACb,MAAM,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC;YAC/B,MAAM,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC;YAE/B,OAAO,KAAK,GAAG,CAAC,MAAM,KAAK,GAAG,CAAC,KAAK;YACpC,OAAO,KAAK,GAAG,CAAC,MAAM,KAAK,GAAG,CAAC,KAAK;YAEpC,IAAI,OAAO,MAAM,OAAO;QAC5B;QAEA,IAAI,QAAQ,KAAK;YACb,MAAM,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC;YAC/B,MAAM,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC;YAE/B,OAAO,KAAK,GAAG,CAAC,MAAM,KAAK,GAAG,CAAC,KAAK;YACpC,OAAO,KAAK,GAAG,CAAC,MAAM,KAAK,GAAG,CAAC,KAAK;YAEpC,IAAI,OAAO,MAAM,OAAO;QAC5B;QAEA,IAAI,OAAO,MAAM,OAAO;QAExB,MAAM;QACN,MAAM,IAAI,8JAAI,GAAG,CAAC,IAAI,8JAAI,KAAK,CAAC,GAAG;QAEnC,sBAAsB;QACtB,MAAM,IAAI,8JAAI,GAAG,CAAC,KAAK,8JAAI,KAAK,CAAC,8JAAI,GAAG,CAAC,KAAK,MAAM;QACpD,MAAM,KAAK,8JAAI,GAAG,CAAC,GAAG;QACtB,MAAM,KAAK,8JAAI,KAAK,CAAC,8JAAI,GAAG,CAAC,KAAK,MAAM;QAExC,MAAM,IAAI,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG,CAAC,IAAI;QAClC,MAAM,IAAI,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG,CAAC,IAAI;QAElC,OAAO;YACH,OAAO;YACP,QAAQ,8JAAI,aAAa,CACrB,8JAAI,MAAM,CAAC,KAAK,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,KACrC,8JAAI,MAAM,CAAC,GAAG;QAEtB;IACJ;IACA;;;;;;;KAOC,GACD,wBAAuB,EAAU,EAAE,EAAU,EAAE,GAAW,EAAE,GAAW;QACnE,IAAI,OAAO;QACX,IAAI,OAAO,OAAO,SAAS;QAE3B,MAAM,MAAM;QACZ,IAAI,IAAI,8JAAI,GAAG,CAAC,IAAI;QACpB,MAAM,OAAO,8JAAI,MAAM,CAAC;QACxB,IAAI,8JAAI,aAAa,CAAC;QAEtB,IAAI,QAAQ,KAAK,GAAG,CAAC,EAAE,CAAC;QACxB,IAAI,QAAQ,KAAK,GAAG,CAAC,EAAE,CAAC;QAExB,IAAI,QAAQ,KAAK;YACb,EAAE,CAAC,GAAG,MAAM;YACZ,QAAQ,EAAE,CAAC;QACf;QAEA,IAAI,QAAQ,KAAK;YACb,EAAE,CAAC,GAAG,MAAM;YACZ,QAAQ,EAAE,CAAC;QACf;QAEA,IAAI,QAAQ,KAAK;YACb,MAAM,MAAM,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC;YAChC,MAAM,MAAM,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC;YAEhC,OAAO,KAAK,GAAG,CAAC,MAAM,KAAK,GAAG,CAAC,KAAK;YACpC,OAAO,KAAK,GAAG,CAAC,MAAM,KAAK,GAAG,CAAC,KAAK;YAEpC,IAAI,OAAO,MAAM,OAAO;QAC5B;QAEA,IAAI,QAAQ,KAAK;YACb,MAAM,MAAM,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC;YAChC,MAAM,MAAM,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC;YAEhC,OAAO,KAAK,GAAG,CAAC,MAAM,KAAK,GAAG,CAAC,KAAK;YACpC,OAAO,KAAK,GAAG,CAAC,MAAM,KAAK,GAAG,CAAC,KAAK;YAEpC,IAAI,OAAO,MAAM,OAAO;QAC5B;QAEA,OAAO,QAAQ;IACnB;IACA,0BAAyB,OAAe,EAAE,OAAe,EAAE,OAAe,EAAE,OAAe;QACvF,MAAM,IAAI,UAAU;QACpB,MAAM,OAAO,8JAAI,GAAG,CAAC,SAAS;QAC9B,MAAM,UAAU,8JAAI,aAAa,CAAC;QAElC,OAAO,UAAU,IAAI,IACf;YACE,KAAK,8JAAI,aAAa,CAAC;YACvB,KAAK,IAAI,KAAK,IAAI,CAAC;QACvB,IACE;IACV;IACA,wBAAuB,GAAW,EAAE,GAAW,EAAE,GAAW,EAAE,MAAc;QACxE,IACI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAChC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,EAClC;YACE,iCAAiC;YAEjC,MAAM,gBAAgB,8JAAI,KAAK,CAAC,8JAAI,GAAG,CAAC,KAAK,MAAM;YACnD,MAAM,IAAI,8JAAI,GAAG,CAAC,KAAK,8JAAI,GAAG,CAAC,KAAK;YACpC,MAAM,KAAK,KAAK,GAAG,CAAC,EAAE,CAAC,IAAI,cAAc,CAAC,GAAG;YAC7C,MAAM,KAAK,KAAK,GAAG,CAAC,EAAE,CAAC,IAAI,cAAc,CAAC,GAAG;YAE7C,OAAO,KAAK,KACN;gBACE,KAAK,8JAAI,MAAM,CACX,EAAE,CAAC,GAAG,IAAI,IAAI,CAAC,GACf;gBAEJ,KAAK,CAAC;YACV,IACE;gBACE,KAAK,8JAAI,MAAM,CACX,GACA,EAAE,CAAC,GAAG,IAAI,IAAI,CAAC;gBAEnB,KAAK,CAAC;YACV;QACR;QAEA,MAAM,MAAM,8JAAI,GAAG,CACf,8JAAI,MAAM,CACN,QAAQ,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,GACjC,QAAQ,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,IAErC;QAEJ,MAAM,SAAS,8JAAI,aAAa,CAAC;QAEjC,IAAI,SAAS,SAAS,QAAQ;YAC1B,MAAM,MAAM,KAAK,IAAI,CAAC;YACtB,OAAO;gBACH,KAAK,8JAAI,aAAa,CAAC;gBACvB,KAAK,SAAS;YAClB;QACJ;QAEA,OAAO;IACX;IACA,gBAAe,CAAS,EAAE,CAAS,EAAE,CAAS;QAC1C,MAAM,KAAK,8JAAI,GAAG,CAAC,GAAG;QAEtB,OAAO,8JAAI,aAAa,CACpB,8JAAI,GAAG,CACH,8JAAI,GAAG,CACH,GACA,8JAAI,KAAK,CACL,IACA,QAAQ,KAAK,CACT,8JAAI,UAAU,CAAC,8JAAI,GAAG,CAAC,GAAG,IAAI,MAAM,8JAAI,UAAU,CAAC,IAAI,KACvD,GAAG,MAIf;IAGZ;IACA;;;KAGC,GACD,mBAAkB,MAAc,EAAE,SAAiB,EAAE,KAAa,EAAE,KAAa;QAC7E,MAAM,UAAU,8JAAI,GAAG,CAAC,OAAO;QAC/B,MAAM,cAAc,8JAAI,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC;QACpD,MAAM,aAAa,8JAAI,UAAU,CAAC,WAAW;QAE7C,yCAAyC;QACzC,IAAI,KAAK,GAAG,CAAC,eAAe,MAAM,OAAO;QAEzC,MAAM,IAAI,8JAAI,GAAG,CAAC,OAAO;QACzB,MAAM,mBAAmB,8JAAI,UAAU,CAAC,aAAa,KAAK;QAC1D,MAAM,oBAAoB,8JAAI,UAAU,CAAC,8JAAI,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,UAAU,CAAC,GAAG,KAAK;QAErF,uEAAuE;QACvE,OAAO,oBAAoB,KAAK,qBAAqB,KAAK,qBAAqB,IAAI,mBAAmB;IAC1G;IACA,sBAAqB,MAAc,EAAE,SAAiB,EAAE,OAAiB;QACrE,IAAI,IAAI,OAAO,SAAS;QAExB,IAAI,cAAc;QAClB,IACI,IAAI,IAAI,GAAG,SAAS,QAAQ,MAAM,EAAE,IAAI,SAAS,GACjD,IAAI,QACJ,IAAI,IACN;YACE,MAAM,OAAO,UAAU,iBAAiB,CAAC,QAAQ,WAAW,OAAO,CAAC,EAAE,EAAE,OAAO,CAAC,EAAE;YAElF,IAAI,SAAS,QAAQ,OAAO,GAAG;gBAC3B,cAAc;gBACd,IAAI;YACR;QACJ;QAEA,+BAA+B;QAC/B,OAAO,cAAc,IAAI;IAC7B;IACA,sBAAqB,IAAY,EAAE,IAAY,EAAE,IAAY,EAAE,IAAY;QACvE,MAAM,KAAK,8JAAI,KAAK,CAAC,8JAAI,GAAG,CAAC,MAAM,OAAO;QAC1C,MAAM,KAAK,8JAAI,KAAK,CAAC,8JAAI,GAAG,CAAC,MAAM,OAAO;QAC1C,MAAM,IAAI,8JAAI,GAAG,CACb,8JAAI,GAAG,CAAC,MAAM,KACd,8JAAI,GAAG,CAAC,MAAM;QAElB,MAAM,KAAK,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,EAAE,CAAC;QACrC,MAAM,KAAK,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,EAAE,CAAC;QAErC,OAAO,KAAK,OAAO,KAAK,MAClB,KAAK,KACD;YACE,KAAK,8JAAI,MAAM,CAAC,KAAK,IAAI,CAAC,EAAE,CAAC,GAAG;YAChC,KAAK;QACT,IACE;YACE,KAAK,8JAAI,MAAM,CAAC,GAAG,KAAK,IAAI,CAAC,EAAE,CAAC;YAChC,KAAK;QACT,IACF;IACV;AACJ;AAiBO,SAAS,sBAKZ,UAA0G,EAC1G,QAAgB,EAChB,QAAqB;IAIrB,IAAI,CAAC,CAAC,WAAW,MAAM,qLAA2B,KAAK,WAAW,IAAI,KAAK,0LAAqB,IAAI,EAAE;QAClG,MAAM,IAAI,MAAM;IACpB;IAQA,OAAQ,WAAW,cAAc;QAC7B,KAAK;YAAS;gBACV,MAAM,aAAa,SAAS,kBAAkB,CAC1C,8JAAI,SAAS,CAAC,UAAU,8JAAI,MAAM,CAAC,CAAC,WAAW,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,AAAC,WAAqB,WAAW,IAAI,CAAC,GAAG,IAAI,WACvI,WAAW,MAAM,CAAC,GAAG,EACrB,WAAW,MAAM,CAAC,GAAG,EACrB,GACA;gBAGJ,yEAAyE;gBACzE,OAAO;oBACH,YAAY,8KAAoB,WAAW,GAAG,EAAE,WAAW,GAAG;gBAClE;YACJ;QACA,KAAK;QACL;YAAS;gBACL,MAAM,gBAAgB,SAAS,kBAAkB,CAC7C,8JAAI,SAAS,CAAC,UAAU,8JAAI,GAAG,CAAC,AAAC,WAAsB,WAAW,EAAE,8JAAI,MAAM,CAAC,CAAC,AAAC,WAAsB,WAAW,CAAC,CAAC,EAAE,AAAC,WAAsB,WAAW,CAAC,CAAC,IAAI,WAC9J,WAAW,MAAM,CAAC,GAAG,EACrB,WAAW,MAAM,CAAC,GAAG,EACrB,GACA,QAAQ,MAAM,CAAC,WAAW,GAAG;gBAEjC,MAAM,mBAAmB,SAAS,kBAAkB,CAChD,8JAAI,SAAS,CAAC,UAAU,8JAAI,GAAG,CAAC,AAAC,WAAsB,WAAW,EAAE,8JAAI,MAAM,CAAC,AAAC,WAAsB,WAAW,CAAC,CAAC,EAAE,CAAC,AAAC,WAAsB,WAAW,CAAC,CAAC,IAAI,WAC9J,WAAW,MAAM,CAAC,GAAG,EACrB,WAAW,MAAM,CAAC,GAAG,EACrB,GACA,QAAQ,MAAM,CAAC,WAAW,GAAG;gBAGjC,yEAAyE;gBACzE,OAAO;oBACH,YAAY,8KAAoB,cAAc,GAAG,EAAE,cAAc,GAAG;oBACpE,eAAe,8KAAoB,iBAAiB,GAAG,EAAE,iBAAiB,GAAG;gBACjF;YACJ;IACJ;AACJ"}},
    {"offset": {"line": 1784, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1789, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/vendor/suroi/common/src/utils/random.ts"],"sourcesContent":["import { Numeric } from \"./math\";\nimport { type Vector } from \"./vector\";\n\n/**\n * Generate a random floating-point value.\n * @param min The minimum value that can be generated.\n * @param max The maximum value that can be generated.\n */\nexport function randomFloat(min: number, max: number): number {\n    return (Math.random() * (max - min) + min);\n}\n\n/**\n * Generate a random integer.\n * @param min The minimum value that can be generated.\n * @param max The maximum value that can be generated.\n * @returns A random integer between `min` and `max`\n */\nexport function random(min: number, max: number): number {\n    return Math.floor(randomFloat(min, max + 1));\n}\n\n/**\n * @returns A random boolean.\n */\nexport function randomBoolean(): boolean {\n    return Math.random() < 0.5;\n}\n\n/**\n * @returns Either `-1` or `1`\n */\nexport function randomSign(): -1 | 1 {\n    return randomBoolean() ? -1 : 1;\n}\n\n/**\n * Generate a vector of random direction and magnitude.\n * @param minX The minimum length in the x-direction.\n * @param maxX The maximum length in the x-direction.\n * @param minY The minimum length in the y-direction.\n * @param maxY The maximum length in the y-direction.\n */\nexport function randomVector(minX: number, maxX: number, minY: number, maxY: number): Vector {\n    return {\n        x: randomFloat(minX, maxX),\n        y: randomFloat(minY, maxY)\n    };\n}\n\n/**\n * @return A random angle in radians.\n */\nexport function randomRotation(): number {\n    return randomFloat(-Math.PI, Math.PI);\n}\n\n/**\n * Generate a random point inside of a circle.\n * @param position The center of the circle.\n * @param radius The radius of the circle.\n * A vector representation of the randomized point.\n */\nexport function randomPointInsideCircle(position: Vector, radius: number): Vector {\n    const angle = randomFloat(0, Math.PI * 2);\n    const length = randomFloat(0, radius);\n    return {\n        x: position.x + (Math.cos(angle) * length),\n        y: position.y + (Math.sin(angle) * length)\n    };\n}\n\n/**\n * Pick a random element from a weighted series of elements.\n * @param items The elements to choose from.\n * @param weights A legend of the elements' relative weights.\n */\nexport function weightedRandom<T>(items: T[], weights: number[]): T {\n    let i: number;\n    for (i = 1; i < weights.length; i++) weights[i] += weights[i - 1];\n\n    const random = Math.random() * weights[weights.length - 1];\n    for (i = 0; i < weights.length; i++) { if (weights[i] > random) break; }\n    return items[i];\n}\n\nexport function pickRandomInArray<T>(items: T[]): T {\n    return items[Math.floor(Math.random() * items.length)];\n}\n\nexport class SeededRandom {\n    rng = 0;\n\n    constructor(seed: number) {\n        this.rng = seed;\n    }\n\n    get(min = 0, max = 1): number {\n        this.rng = this.rng * 16807 % 2147483647;\n        return Numeric.lerp(min, max, (this.rng / 2147483647));\n    }\n\n    getInt(min?: number, max?: number): number {\n        return Math.round(this.get(min, max));\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAQO,SAAS,YAAY,GAAW,EAAE,GAAW;IAChD,OAAQ,KAAK,MAAM,KAAK,CAAC,MAAM,GAAG,IAAI;AAC1C;AAQO,SAAS,OAAO,GAAW,EAAE,GAAW;IAC3C,OAAO,KAAK,KAAK,CAAC,YAAY,KAAK,MAAM;AAC7C;AAKO,SAAS;IACZ,OAAO,KAAK,MAAM,KAAK;AAC3B;AAKO,SAAS;IACZ,OAAO,kBAAkB,CAAC,IAAI;AAClC;AASO,SAAS,aAAa,IAAY,EAAE,IAAY,EAAE,IAAY,EAAE,IAAY;IAC/E,OAAO;QACH,GAAG,YAAY,MAAM;QACrB,GAAG,YAAY,MAAM;IACzB;AACJ;AAKO,SAAS;IACZ,OAAO,YAAY,CAAC,KAAK,EAAE,EAAE,KAAK,EAAE;AACxC;AAQO,SAAS,wBAAwB,QAAgB,EAAE,MAAc;IACpE,MAAM,QAAQ,YAAY,GAAG,KAAK,EAAE,GAAG;IACvC,MAAM,SAAS,YAAY,GAAG;IAC9B,OAAO;QACH,GAAG,SAAS,CAAC,GAAI,KAAK,GAAG,CAAC,SAAS;QACnC,GAAG,SAAS,CAAC,GAAI,KAAK,GAAG,CAAC,SAAS;IACvC;AACJ;AAOO,SAAS,eAAkB,KAAU,EAAE,OAAiB;IAC3D,IAAI;IACJ,IAAK,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,IAAK,OAAO,CAAC,EAAE,IAAI,OAAO,CAAC,IAAI,EAAE;IAEjE,MAAM,SAAS,KAAK,MAAM,KAAK,OAAO,CAAC,QAAQ,MAAM,GAAG,EAAE;IAC1D,IAAK,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,IAAK;QAAE,IAAI,OAAO,CAAC,EAAE,GAAG,QAAQ;IAAO;IACvE,OAAO,KAAK,CAAC,EAAE;AACnB;AAEO,SAAS,kBAAqB,KAAU;IAC3C,OAAO,KAAK,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,MAAM,MAAM,EAAE;AAC1D;AAEO,MAAM;IACT,MAAM,EAAE;IAER,YAAY,IAAY,CAAE;QACtB,IAAI,CAAC,GAAG,GAAG;IACf;IAEA,IAAI,MAAM,CAAC,EAAE,MAAM,CAAC,EAAU;QAC1B,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,GAAG,QAAQ;QAC9B,OAAO,gKAAQ,IAAI,CAAC,KAAK,KAAM,IAAI,CAAC,GAAG,GAAG;IAC9C;IAEA,OAAO,GAAY,EAAE,GAAY,EAAU;QACvC,OAAO,KAAK,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK;IACpC;AACJ"}},
    {"offset": {"line": 1858, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1863, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/lib/util/calculators.ts"],"sourcesContent":["import { GunDefinition } from \"@/vendor/suroi/common/src/definitions/guns\";\nimport {\n  Angle,\n  Collision,\n} from \"@/vendor/suroi/common/src/utils/math\";\nimport {\n  randomFloat,\n  randomPointInsideCircle,\n} from \"@/vendor/suroi/common/src/utils/random\";\nimport { Vec } from \"@/vendor/suroi/common/src/utils/vector\";\n\nexport const PLAYERRADIUS = 2.25;\n\nexport function shootGun(gun: GunDefinition, trials: number, range: number) {\n  let damage = 0;\n\n  for (let trial = 0; trial < trials; trial++) {\n    const spread = Angle.degreesToRadians(gun.moveSpread / 2);\n    const jitter = gun.jitterRadius ?? 0;\n\n    const limit = gun.bulletCount ?? 1;\n\n    for (let i = 0; i < limit; i++) {\n      const rayStart = gun.jitterRadius\n        ? randomPointInsideCircle(Vec.create(0, 0), jitter)\n        : Vec.create(0, 0);\n      const ray = Vec.add(\n        Vec.fromPolar(\n          gun.consistentPatterning === true\n            ? 2 * (i / limit - 0.5)\n            : randomFloat(-1, 1) * spread,\n          gun.ballistics.range\n        ),\n        rayStart\n      );\n\n      damage += Collision.lineIntersectsCircle(rayStart, ray, Vec.create(range, 0), PLAYERRADIUS) ? gun.ballistics.damage : 0;\n    }\n  }\n\n  return damage / trials;\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAWO,MAAM,eAAe;AAErB,SAAS,SAAS,GAAkB,EAAE,MAAc,EAAE,KAAa;IACxE,IAAI,SAAS;IAEb,IAAK,IAAI,QAAQ,GAAG,QAAQ,QAAQ,QAAS;QAC3C,MAAM,SAAS,8JAAM,gBAAgB,CAAC,IAAI,UAAU,GAAG;QACvD,MAAM,SAAS,IAAI,YAAY,IAAI;QAEnC,MAAM,QAAQ,IAAI,WAAW,IAAI;QAEjC,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK;YAC9B,MAAM,WAAW,IAAI,YAAY,GAC7B,kLAAwB,8JAAI,MAAM,CAAC,GAAG,IAAI,UAC1C,8JAAI,MAAM,CAAC,GAAG;YAClB,MAAM,MAAM,8JAAI,GAAG,CACjB,8JAAI,SAAS,CACX,IAAI,oBAAoB,KAAK,OACzB,IAAI,CAAC,IAAI,QAAQ,GAAG,IACpB,sKAAY,CAAC,GAAG,KAAK,QACzB,IAAI,UAAU,CAAC,KAAK,GAEtB;YAGF,UAAU,kKAAU,oBAAoB,CAAC,UAAU,KAAK,8JAAI,MAAM,CAAC,OAAO,IAAI,gBAAgB,IAAI,UAAU,CAAC,MAAM,GAAG;QACxH;IACF;IAEA,OAAO,SAAS;AAClB"}},
    {"offset": {"line": 1889, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1894, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/components/interactive/GunGraph.tsx"],"sourcesContent":["\"use client\";\n\nimport { shootGun } from \"@/lib/util/calculators\";\nimport { GunDefinition } from \"@/vendor/suroi/common/src/definitions/guns\";\nimport { Suspense, useRef } from \"react\";\nimport {\n  Chart,\n  ScatterController,\n  LinearScale,\n  PointElement,\n  Legend,\n  Tooltip,\n  Title,\n} from \"chart.js\";\nimport { Scatter } from \"react-chartjs-2\";\nimport { FireMode } from \"@/vendor/suroi/common/src/constants\";\n\nexport default function GunGraph({ gun }: GunGraphProps) {\n  Chart.register(\n    ScatterController,\n    LinearScale,\n    PointElement,\n    Legend,\n    Tooltip,\n    Title\n  );\n\n  const graphCanvas = useRef(null);\n\n  function calculate(gun: GunDefinition) {\n    let data = [];\n\n    for (\n      let range = -10;\n      range < gun.ballistics.range + 10;\n      range += gun.ballistics.range / 750\n    ) {\n      data.push({\n        x: range,\n        y: shootGun(gun, 500 / (gun.bulletCount ?? 1), range),\n      });\n    }\n    return data;\n  }\n\n  const damages = calculate(gun);\n  const dps = damages.map((damage) => ({\n    x: damage.x,\n    y:\n      gun.fireMode === FireMode.Burst\n        ? damage.y *\n          (1000 /\n            (gun.burstProperties.burstCooldown +\n              gun.fireDelay * gun.burstProperties.shotsPerBurst))\n        : damage.y * (1000 / gun.fireDelay),\n  }));\n\n  return (\n    <div className=\"prose prose-invert\">\n      <p>\n        This test assumes that the target isn{\"'\"}t moving and the gun is aiming\n        dead center on the target.\n      </p>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Scatter\n          data={{\n            datasets: [\n              {\n                label: `Simulated Damage of ${gun.name}`,\n                data: damages,\n                backgroundColor: \"hsl(209, 60%, 51%)\",\n              },\n              {\n                label: `Simulated DPS of ${gun.name}`,\n                data: dps,\n                backgroundColor: \"hsl(27, 100%, 50%)\",\n              },\n            ],\n          }}\n          options={{\n            aspectRatio: 1.3,\n            scales: {\n              x: {\n                grid: {\n                  color: [\"#444\", \"#888\"],\n                },\n                ticks: {\n                  color: \"white\",\n                  stepSize: 10,\n                },\n                title: {\n                  text: \"Distance between target center and muzzle in game units\",\n                  display: true,\n                  color: \"white\",\n                },\n              },\n              y: {\n                grid: {\n                  color: [\"#444\", \"#888\"],\n                },\n                ticks: {\n                  color: \"white\",\n                },\n                title: {\n                  text: \"Damage value\",\n                  display: true,\n                  color: \"white\",\n                },\n              },\n            },\n            plugins: {\n              title: {\n                text: `Simulated damages of ${gun.name}`,\n                display: true,\n                color: \"white\",\n              },\n              legend: {\n                labels: {\n                  color: \"white\",\n                },\n              },\n              tooltip: {\n                filter: (item, i) => {\n                  return i === 0;\n                },\n              },\n            },\n          }}\n        />\n        <p>CSV for damage</p>\n        <span className=\"not-prose select-all p-4 rounded-md flex flex-col h-16 bg-muted overflow-y-auto\">\n          Distance between target center and muzzle in game units, Damage\n          <br></br>\n          {damages.map((damage, i) => (\n            <span key={i}>\n              {damage.x.toFixed(2)}, {damage.y.toFixed(2)}\n              <br></br>\n            </span>\n          ))}\n        </span>\n        <p>CSV for DPS</p>\n        <span className=\"not-prose select-all p-4 rounded-md flex flex-col h-16 bg-muted overflow-y-auto\">\n          Distance between target center and muzzle in game units, DPS\n          <br></br>\n          {dps.map((damage, i) => (\n            <span key={i}>\n              {damage.x.toFixed(2)}, {damage.y.toFixed(2)}\n              <br></br>\n            </span>\n          ))}\n        </span>\n      </Suspense>\n    </div>\n  );\n}\n\nexport interface GunGraphProps extends React.PropsWithChildren {\n  gun: GunDefinition;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;;;;;AAiBe,SAAS,SAAS,EAAE,GAAG,EAAiB;;IACrD,iNAAM,QAAQ;IASd,MAAM,cAAc,6QAAO;IAE3B,SAAS,UAAU,GAAkB;QACnC,IAAI,OAAO,EAAE;QAEb,IACE,IAAI,QAAQ,CAAC,IACb,QAAQ,IAAI,UAAU,CAAC,KAAK,GAAG,IAC/B,SAAS,IAAI,UAAU,CAAC,KAAK,GAAG,IAChC;YACA,KAAK,IAAI,CAAC;gBACR,GAAG;gBACH,GAAG,0IAAS,KAAK,MAAM,CAAC,IAAI,WAAW,IAAI,CAAC,GAAG;YACjD;QACF;QACA,OAAO;IACT;IAEA,MAAM,UAAU,UAAU;IAC1B,MAAM,MAAM,QAAQ,GAAG,CAAC,CAAC,SAAW,CAAC;YACnC,GAAG,OAAO,CAAC;YACX,GACE,IAAI,QAAQ,KAAK,6JAAS,KAAK,GAC3B,OAAO,CAAC,GACR,CAAC,OACC,CAAC,IAAI,eAAe,CAAC,aAAa,GAChC,IAAI,SAAS,GAAG,IAAI,eAAe,CAAC,aAAa,CAAC,IACtD,OAAO,CAAC,GAAG,CAAC,OAAO,IAAI,SAAS;QACxC,CAAC;IAED,qBACE,6RAAC;QAAI,WAAU;;0BACb,6RAAC;;oBAAE;oBACqC;oBAAI;;;;;;;0BAG5C;gBAAU,wBAAU,6RAAC;8BAAI;;;;;;;kCACvB;wBACE,MAAM;4BACJ,UAAU;gCACR;oCACE,OAAO,CAAC,oBAAoB,EAAE,IAAI,IAAI,CAAC,CAAC;oCACxC,MAAM;oCACN,iBAAiB;gCACnB;gCACA;oCACE,OAAO,CAAC,iBAAiB,EAAE,IAAI,IAAI,CAAC,CAAC;oCACrC,MAAM;oCACN,iBAAiB;gCACnB;6BACD;wBACH;wBACA,SAAS;4BACP,aAAa;4BACb,QAAQ;gCACN,GAAG;oCACD,MAAM;wCACJ,OAAO;4CAAC;4CAAQ;yCAAO;oCACzB;oCACA,OAAO;wCACL,OAAO;wCACP,UAAU;oCACZ;oCACA,OAAO;wCACL,MAAM;wCACN,SAAS;wCACT,OAAO;oCACT;gCACF;gCACA,GAAG;oCACD,MAAM;wCACJ,OAAO;4CAAC;4CAAQ;yCAAO;oCACzB;oCACA,OAAO;wCACL,OAAO;oCACT;oCACA,OAAO;wCACL,MAAM;wCACN,SAAS;wCACT,OAAO;oCACT;gCACF;4BACF;4BACA,SAAS;gCACP,OAAO;oCACL,MAAM,CAAC,qBAAqB,EAAE,IAAI,IAAI,CAAC,CAAC;oCACxC,SAAS;oCACT,OAAO;gCACT;gCACA,QAAQ;oCACN,QAAQ;wCACN,OAAO;oCACT;gCACF;gCACA,SAAS;oCACP,QAAQ,CAAC,MAAM;wCACb,OAAO,MAAM;oCACf;gCACF;4BACF;wBACF;;;;;;kCAEF,6RAAC;kCAAE;;;;;;kCACH,6RAAC;wBAAK,WAAU;;4BAAkF;0CAEhG,6RAAC;;;;;4BACA,QAAQ,GAAG,CAAC,CAAC,QAAQ,kBACpB,6RAAC;;wCACE,OAAO,CAAC,CAAC,OAAO,CAAC;wCAAG;wCAAG,OAAO,CAAC,CAAC,OAAO,CAAC;sDACzC,6RAAC;;;;;;mCAFQ;;;;;;;;;;;kCAMf,6RAAC;kCAAE;;;;;;kCACH,6RAAC;wBAAK,WAAU;;4BAAkF;0CAEhG,6RAAC;;;;;4BACA,IAAI,GAAG,CAAC,CAAC,QAAQ,kBAChB,6RAAC;;wCACE,OAAO,CAAC,CAAC,OAAO,CAAC;wCAAG;wCAAG,OAAO,CAAC,CAAC,OAAO,CAAC;sDACzC,6RAAC;;;;;;mCAFQ;;;;;;;;;;;;;;;;;;;;;;;AASvB;GAzIwB;KAAA"}},
    {"offset": {"line": 2122, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2127, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/components/interactive/GunGraphButton.tsx"],"sourcesContent":["\"use client\";\n\nimport { useState } from \"react\";\nimport GunGraph, { GunGraphProps } from \"./GunGraph\";\n\nexport default function GunGraphButton({ gun }: GunGraphProps) {\n  const [open, setOpen] = useState(false);\n\n  return (\n    <>\n      {(open && (\n        <>\n          <h1>Gun Graph</h1> <GunGraph gun={gun} />\n        </>\n      )) || (\n        <button\n          className=\"transition-color bg-muted p-4 not-prose rounded-md ring-border ring hover:ring-primary\"\n          onClick={() => setOpen(true)}\n        >\n          Open Gun Graph (May be laggy, especially on mobile)\n        </button>\n      )}\n    </>\n  );\n}\n"],"names":[],"mappings":";;;;;;;;;AAAA;;;AAKe,SAAS,eAAe,EAAE,GAAG,EAAiB;;IAC3D,MAAM,CAAC,MAAM,QAAQ,GAAG,+QAAS;IAEjC,qBACE;kBACG,AAAC,sBACA;;8BACE,6RAAC;8BAAG;;;;;;gBAAc;8BAAC;oBAAU,KAAK;;;;;;;0CAGpC,6RAAC;YACC,WAAU;YACV,SAAS,IAAM,QAAQ;sBACxB;;;;;;;AAMT;GAnBwB;KAAA"}},
    {"offset": {"line": 2176, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}