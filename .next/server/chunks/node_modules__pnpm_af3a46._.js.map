{
  "version": 3,
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@2.3.3/node_modules/hast-util-to-estree/lib/handlers/root.js"],"sourcesContent":["/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('estree-jsx').JSXFragment} JsxFragment\n * @typedef {JsxFragment['children'][number]} JsxChild\n * @typedef {import('../state.js').State} State\n */\n\nimport {whitespace} from 'hast-util-whitespace'\n\n/**\n * Turn a hast root node into an estree node.\n *\n * @param {Root} node\n *   hast node to transform.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {JsxFragment}\n *   estree JSX fragment.\n */\nexport function root(node, state) {\n  const children = state.all(node)\n  /** @type {Array<JsxChild>} */\n  const cleanChildren = []\n  let index = -1\n  /** @type {Array<JsxChild> | undefined} */\n  let queue\n\n  // Remove surrounding whitespace nodes from the fragment.\n  while (++index < children.length) {\n    const child = children[index]\n\n    if (\n      child.type === 'JSXExpressionContainer' &&\n      child.expression.type === 'Literal' &&\n      whitespace(child.expression.value)\n    ) {\n      if (queue) queue.push(child)\n    } else {\n      if (queue) cleanChildren.push(...queue)\n      cleanChildren.push(child)\n      queue = []\n    }\n  }\n\n  /** @type {JsxFragment} */\n  const result = {\n    type: 'JSXFragment',\n    openingFragment: {type: 'JSXOpeningFragment'},\n    closingFragment: {type: 'JSXClosingFragment'},\n    children: cleanChildren\n  }\n  state.inherit(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;AAcM,SAAS,KAAK,IAAI,EAAE,KAAK;IAC9B,MAAM,WAAW,MAAM,GAAG,CAAC;IAC3B,4BAA4B,GAC5B,MAAM,gBAAgB,EAAE;IACxB,IAAI,QAAQ,CAAC;IACb,wCAAwC,GACxC,IAAI;IAEJ,yDAAyD;IACzD,MAAO,EAAE,QAAQ,SAAS,MAAM,CAAE;QAChC,MAAM,QAAQ,QAAQ,CAAC,MAAM;QAE7B,IACE,MAAM,IAAI,KAAK,4BACf,MAAM,UAAU,CAAC,IAAI,KAAK,aAC1B,kOAAW,MAAM,UAAU,CAAC,KAAK,GACjC;YACA,IAAI,OAAO,MAAM,IAAI,CAAC;QACxB,OAAO;YACL,IAAI,OAAO,cAAc,IAAI,IAAI;YACjC,cAAc,IAAI,CAAC;YACnB,QAAQ,EAAE;QACZ;IACF;IAEA,wBAAwB,GACxB,MAAM,SAAS;QACb,MAAM;QACN,iBAAiB;YAAC,MAAM;QAAoB;QAC5C,iBAAiB;YAAC,MAAM;QAAoB;QAC5C,UAAU;IACZ;IACA,MAAM,OAAO,CAAC,MAAM;IACpB,OAAO;AACT"}},
    {"offset": {"line": 45, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 50, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@2.3.3/node_modules/hast-util-to-estree/lib/handlers/text.js"],"sourcesContent":["/**\n * @typedef {import('hast').Text} Text\n * @typedef {import('estree').Literal} Literal\n * @typedef {import('estree-jsx').JSXExpressionContainer} JsxExpressionContainer\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn a hast text node into an estree node.\n *\n * @param {Text} node\n *   hast node to transform.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {JsxExpressionContainer | void}\n *   JSX expression.\n */\nexport function text(node, state) {\n  const value = String(node.value || '')\n\n  if (value) {\n    /** @type {Literal} */\n    const result = {type: 'Literal', value}\n    state.inherit(node, result)\n    /** @type {JsxExpressionContainer} */\n    const container = {type: 'JSXExpressionContainer', expression: result}\n    state.patch(node, container)\n    return container\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED;;;;;;;;;CASC;;;AACM,SAAS,KAAK,IAAI,EAAE,KAAK;IAC9B,MAAM,QAAQ,OAAO,KAAK,KAAK,IAAI;IAEnC,IAAI,OAAO;QACT,oBAAoB,GACpB,MAAM,SAAS;YAAC,MAAM;YAAW;QAAK;QACtC,MAAM,OAAO,CAAC,MAAM;QACpB,mCAAmC,GACnC,MAAM,YAAY;YAAC,MAAM;YAA0B,YAAY;QAAM;QACrE,MAAM,KAAK,CAAC,MAAM;QAClB,OAAO;IACT;AACF"}},
    {"offset": {"line": 83, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@2.3.3/node_modules/hast-util-to-estree/lib/handlers/mdxjs-esm.js"],"sourcesContent":["/**\n * @typedef {import('mdast-util-mdxjs-esm').MdxjsEsm} MdxjsEsm\n * @typedef {import('../state.js').State} State\n */\n\nimport {attachComments} from 'estree-util-attach-comments'\n\n/**\n * Handle an MDX ESM node.\n *\n * @param {MdxjsEsm} node\n *   hast node to transform.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {void}\n *   Nothing.\n */\nexport function mdxjsEsm(node, state) {\n  const estree = node.data && node.data.estree\n  const comments = (estree && estree.comments) || []\n\n  if (estree) {\n    state.comments.push(...comments)\n    attachComments(estree, comments)\n    state.esm.push(...estree.body)\n  }\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAcM,SAAS,SAAS,IAAI,EAAE,KAAK;IAClC,MAAM,SAAS,KAAK,IAAI,IAAI,KAAK,IAAI,CAAC,MAAM;IAC5C,MAAM,WAAW,AAAC,UAAU,OAAO,QAAQ,IAAK,EAAE;IAElD,IAAI,QAAQ;QACV,MAAM,QAAQ,CAAC,IAAI,IAAI;QACvB,0PAAe,QAAQ;QACvB,MAAM,GAAG,CAAC,IAAI,IAAI,OAAO,IAAI;IAC/B;AACF"}},
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@2.3.3/node_modules/hast-util-to-estree/lib/handlers/mdx-jsx-element.js"],"sourcesContent":["/**\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxFlowElement} MdxJsxFlowElement\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxTextElement} MdxJsxTextElement\n * @typedef {import('estree').Expression} Expression\n * @typedef {import('estree-jsx').JSXElement} JsxElement\n * @typedef {import('estree-jsx').JSXFragment} JsxFragment\n * @typedef {import('estree-jsx').JSXAttribute} JsxAttribute\n * @typedef {import('estree-jsx').JSXSpreadAttribute} JsxSpreadAttribute\n * @typedef {import('../state.js').State} State\n */\n\nimport {attachComments} from 'estree-util-attach-comments'\nimport {svg} from 'property-information'\n\n/**\n * Turn an MDX JSX element node into an estree node.\n *\n * @param {MdxJsxFlowElement | MdxJsxTextElement} node\n *   hast node to transform.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {JsxElement | JsxFragment}\n *   JSX element or fragment.\n */\n// eslint-disable-next-line complexity\nexport function mdxJsxElement(node, state) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n  const attrs = node.attributes || []\n  let index = -1\n\n  if (\n    node.name &&\n    parentSchema.space === 'html' &&\n    node.name.toLowerCase() === 'svg'\n  ) {\n    schema = svg\n    state.schema = schema\n  }\n\n  const children = state.all(node)\n  /** @type {Array<JsxAttribute | JsxSpreadAttribute>} */\n  const attributes = []\n\n  while (++index < attrs.length) {\n    const attr = attrs[index]\n    const value = attr.value\n    /** @type {JsxAttribute['value']} */\n    let attributeValue\n\n    if (attr.type === 'mdxJsxAttribute') {\n      if (value === undefined || value === null) {\n        attributeValue = null\n        // Empty.\n      }\n      // `MdxJsxAttributeValueExpression`.\n      else if (typeof value === 'object') {\n        const estree = value.data && value.data.estree\n        const comments = (estree && estree.comments) || []\n        /** @type {Expression | undefined} */\n        let expression\n\n        if (estree) {\n          state.comments.push(...comments)\n          attachComments(estree, estree.comments)\n          // Should exist.\n          /* c8 ignore next 5 */\n          expression =\n            (estree.body[0] &&\n              estree.body[0].type === 'ExpressionStatement' &&\n              estree.body[0].expression) ||\n            undefined\n        }\n\n        attributeValue = {\n          type: 'JSXExpressionContainer',\n          expression: expression || {type: 'JSXEmptyExpression'}\n        }\n        state.inherit(value, attributeValue)\n      }\n      // Anything else.\n      else {\n        attributeValue = {type: 'Literal', value: String(value)}\n      }\n\n      /** @type {JsxAttribute} */\n      const attribute = {\n        type: 'JSXAttribute',\n        name: state.createJsxAttributeName(attr.name),\n        value: attributeValue\n      }\n\n      state.inherit(attr, attribute)\n      attributes.push(attribute)\n    }\n    // MdxJsxExpressionAttribute.\n    else {\n      const estree = attr.data && attr.data.estree\n      const comments = (estree && estree.comments) || []\n      /** @type {JsxSpreadAttribute['argument'] | undefined} */\n      let argumentValue\n\n      if (estree) {\n        state.comments.push(...comments)\n        attachComments(estree, estree.comments)\n        // Should exist.\n        /* c8 ignore next 10 */\n        argumentValue =\n          (estree.body[0] &&\n            estree.body[0].type === 'ExpressionStatement' &&\n            estree.body[0].expression &&\n            estree.body[0].expression.type === 'ObjectExpression' &&\n            estree.body[0].expression.properties &&\n            estree.body[0].expression.properties[0] &&\n            estree.body[0].expression.properties[0].type === 'SpreadElement' &&\n            estree.body[0].expression.properties[0].argument) ||\n          undefined\n      }\n\n      /** @type {JsxSpreadAttribute} */\n      const attribute = {\n        type: 'JSXSpreadAttribute',\n        argument: argumentValue || {type: 'ObjectExpression', properties: []}\n      }\n      state.inherit(attr, attribute)\n      attributes.push(attribute)\n    }\n  }\n\n  // Restore parent schema.\n  state.schema = parentSchema\n\n  /** @type {JsxElement | JsxFragment} */\n  const result = node.name\n    ? {\n        type: 'JSXElement',\n        openingElement: {\n          type: 'JSXOpeningElement',\n          attributes,\n          name: state.createJsxElementName(node.name),\n          selfClosing: children.length === 0\n        },\n        closingElement:\n          children.length > 0\n            ? {\n                type: 'JSXClosingElement',\n                name: state.createJsxElementName(node.name)\n              }\n            : null,\n        children\n      }\n    : {\n        type: 'JSXFragment',\n        openingFragment: {type: 'JSXOpeningFragment'},\n        closingFragment: {type: 'JSXClosingFragment'},\n        children\n      }\n\n  state.inherit(node, result)\n  return result\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 226, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 231, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@2.3.3/node_modules/hast-util-to-estree/lib/handlers/mdx-expression.js"],"sourcesContent":["/**\n * @typedef {import('mdast-util-mdx-expression').MdxFlowExpression} MdxFlowExpression\n * @typedef {import('mdast-util-mdx-expression').MdxTextExpression} MdxTextExpression\n * @typedef {import('estree').Expression} Expression\n * @typedef {import('estree-jsx').JSXEmptyExpression} JsxEmptyExpression\n * @typedef {import('estree-jsx').JSXExpressionContainer} JsxExpressionContainer\n * @typedef {import('../state.js').State} State\n */\n\nimport {attachComments} from 'estree-util-attach-comments'\n\n/**\n * Turn an MDX expression node into an estree node.\n *\n * @param {MdxFlowExpression | MdxTextExpression} node\n *   hast node to transform.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {JsxExpressionContainer}\n *   estree expression.\n */\nexport function mdxExpression(node, state) {\n  const estree = node.data && node.data.estree\n  const comments = (estree && estree.comments) || []\n  /** @type {Expression | JsxEmptyExpression | undefined} */\n  let expression\n\n  if (estree) {\n    state.comments.push(...comments)\n    attachComments(estree, estree.comments)\n    expression =\n      (estree.body[0] &&\n        estree.body[0].type === 'ExpressionStatement' &&\n        estree.body[0].expression) ||\n      undefined\n  }\n\n  if (!expression) {\n    expression = {type: 'JSXEmptyExpression'}\n    state.patch(node, expression)\n  }\n\n  /** @type {JsxExpressionContainer} */\n  const result = {type: 'JSXExpressionContainer', expression}\n  state.inherit(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC;;;;;;AAcM,SAAS,cAAc,IAAI,EAAE,KAAK;IACvC,MAAM,SAAS,KAAK,IAAI,IAAI,KAAK,IAAI,CAAC,MAAM;IAC5C,MAAM,WAAW,AAAC,UAAU,OAAO,QAAQ,IAAK,EAAE;IAClD,wDAAwD,GACxD,IAAI;IAEJ,IAAI,QAAQ;QACV,MAAM,QAAQ,CAAC,IAAI,IAAI;QACvB,0PAAe,QAAQ,OAAO,QAAQ;QACtC,aACE,AAAC,OAAO,IAAI,CAAC,EAAE,IACb,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,KAAK,yBACxB,OAAO,IAAI,CAAC,EAAE,CAAC,UAAU,IAC3B;IACJ;IAEA,IAAI,CAAC,YAAY;QACf,aAAa;YAAC,MAAM;QAAoB;QACxC,MAAM,KAAK,CAAC,MAAM;IACpB;IAEA,mCAAmC,GACnC,MAAM,SAAS;QAAC,MAAM;QAA0B;IAAU;IAC1D,MAAM,OAAO,CAAC,MAAM;IACpB,OAAO;AACT"}},
    {"offset": {"line": 266, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 271, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@2.3.3/node_modules/hast-util-to-estree/lib/handlers/element.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('estree').Property} Property\n * @typedef {import('estree-jsx').JSXElement} JsxElement\n * @typedef {import('estree-jsx').JSXSpreadAttribute} JsxSpreadAttribute\n * @typedef {import('estree-jsx').JSXAttribute} JsxAttribute\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Record<string, string>} Style\n */\n\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {svg, find, hastToReact} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {\n  start as identifierStart,\n  cont as identifierCont,\n  name as identifierName\n} from 'estree-util-is-identifier-name'\nimport styleToObject from 'style-to-object'\n\nconst own = {}.hasOwnProperty\nconst cap = /[A-Z]/g\nconst dashSomething = /-([a-z])/g\n\n/**\n * Turn a hast element into an estree node.\n *\n * @param {Element} node\n *   hast node to transform.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {JsxElement}\n *   estree expression.\n */\n// eslint-disable-next-line complexity\nexport function element(node, state) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n  const props = node.properties || {}\n\n  if (parentSchema.space === 'html' && node.tagName.toLowerCase() === 'svg') {\n    schema = svg\n    state.schema = schema\n  }\n\n  const children = state.all(node)\n\n  /** @type {Array<JsxAttribute | JsxSpreadAttribute>} */\n  const attributes = []\n  /** @type {string} */\n  let prop\n\n  for (prop in props) {\n    if (own.call(props, prop)) {\n      let value = props[prop]\n      const info = find(schema, prop)\n      /** @type {JsxAttribute['value']} */\n      let attributeValue\n\n      // Ignore nullish and `NaN` values.\n      // Ignore `false` and falsey known booleans.\n      if (\n        value === undefined ||\n        value === null ||\n        (typeof value === 'number' && Number.isNaN(value)) ||\n        value === false ||\n        (!value && info.boolean)\n      ) {\n        continue\n      }\n\n      prop =\n        state.elementAttributeNameCase === 'react' && info.space\n          ? hastToReact[info.property] || info.property\n          : info.attribute\n\n      if (Array.isArray(value)) {\n        // Accept `array`.\n        // Most props are space-separated.\n        value = info.commaSeparated ? commas(value) : spaces(value)\n      }\n\n      if (prop === 'style') {\n        let styleObject =\n          typeof value === 'object'\n            ? value\n            : parseStyle(String(value), node.tagName)\n\n        if (state.stylePropertyNameCase === 'css') {\n          styleObject = transformStyleToCssCasing(styleObject)\n        }\n\n        /** @type {Array<Property>} */\n        const cssProperties = []\n        /** @type {string} */\n        let cssProp\n\n        for (cssProp in styleObject) {\n          // eslint-disable-next-line max-depth\n          if (own.call(styleObject, cssProp)) {\n            cssProperties.push({\n              type: 'Property',\n              method: false,\n              shorthand: false,\n              computed: false,\n              key: identifierName(cssProp)\n                ? {type: 'Identifier', name: cssProp}\n                : {type: 'Literal', value: cssProp},\n              value: {type: 'Literal', value: String(styleObject[cssProp])},\n              kind: 'init'\n            })\n          }\n        }\n\n        attributeValue = {\n          type: 'JSXExpressionContainer',\n          expression: {type: 'ObjectExpression', properties: cssProperties}\n        }\n      } else if (value === true) {\n        attributeValue = null\n      } else {\n        attributeValue = {type: 'Literal', value: String(value)}\n      }\n\n      if (jsxIdentifierName(prop)) {\n        attributes.push({\n          type: 'JSXAttribute',\n          name: {type: 'JSXIdentifier', name: prop},\n          value: attributeValue\n        })\n      } else {\n        attributes.push({\n          type: 'JSXSpreadAttribute',\n          argument: {\n            type: 'ObjectExpression',\n            properties: [\n              {\n                type: 'Property',\n                method: false,\n                shorthand: false,\n                computed: false,\n                key: {type: 'Literal', value: String(prop)},\n                // @ts-expect-error No need to worry about `style` (which has a\n                // `JSXExpressionContainer` value) because that’s a valid identifier.\n                value: attributeValue || {type: 'Literal', value: true},\n                kind: 'init'\n              }\n            ]\n          }\n        })\n      }\n    }\n  }\n\n  // Restore parent schema.\n  state.schema = parentSchema\n\n  /** @type {JsxElement} */\n  const result = {\n    type: 'JSXElement',\n    openingElement: {\n      type: 'JSXOpeningElement',\n      attributes,\n      name: state.createJsxElementName(node.tagName),\n      selfClosing: children.length === 0\n    },\n    closingElement:\n      children.length > 0\n        ? {\n            type: 'JSXClosingElement',\n            name: state.createJsxElementName(node.tagName)\n          }\n        : null,\n    children\n  }\n  state.inherit(node, result)\n  return result\n}\n\n/**\n * Parse CSS rules as a declaration.\n *\n * @param {string} value\n *   CSS text.\n * @param {string} tagName\n *   Element name.\n * @returns {Style}\n *   Props.\n */\nfunction parseStyle(value, tagName) {\n  /** @type {Style} */\n  const result = {}\n\n  try {\n    styleToObject(value, iterator)\n  } catch (error) {\n    const exception = /** @type {Error} */ (error)\n    exception.message =\n      tagName + '[style]' + exception.message.slice('undefined'.length)\n    throw error\n  }\n\n  return result\n\n  /**\n   * Add `name`, as a CSS prop, to `result`.\n   *\n   * @param {string} name\n   *   Key.\n   * @param {string} value\n   *   Value.\n   * @returns {void}\n   *   Nothing.\n   */\n  function iterator(name, value) {\n    let key = name\n\n    if (key.slice(0, 2) !== '--') {\n      // See: <https://alanhogan.com/code/vendor-prefixed-css-property-names-in-javascript>\n      if (key.slice(0, 4) === '-ms-') key = 'ms-' + key.slice(4)\n      key = key.replace(dashSomething, toCamel)\n    }\n\n    result[key] = value\n  }\n}\n\n/**\n * Transform a DOM casing style object to a CSS casing style object.\n *\n * @param {Style} domCasing\n * @returns {Style}\n */\nfunction transformStyleToCssCasing(domCasing) {\n  /** @type {Style} */\n  const cssCasing = {}\n  /** @type {string} */\n  let from\n\n  for (from in domCasing) {\n    if (own.call(domCasing, from)) {\n      let to = from.replace(cap, toDash)\n      // Handle `ms-xxx` -> `-ms-xxx`.\n      if (to.slice(0, 3) === 'ms-') to = '-' + to\n      cssCasing[to] = domCasing[from]\n    }\n  }\n\n  return cssCasing\n}\n\n/**\n * Make `$1` capitalized.\n *\n * @param {string} _\n *   Whatever.\n * @param {string} $1\n *   Single ASCII alphabetical.\n * @returns {string}\n *   Capitalized `$1`.\n */\nfunction toCamel(_, $1) {\n  return $1.toUpperCase()\n}\n\n/**\n * Make `$0` dash cased.\n *\n * @param {string} $0\n *   Capitalized ASCII leter.\n * @returns {string}\n *   Dash and lower letter.\n */\nfunction toDash($0) {\n  return '-' + $0.toLowerCase()\n}\n\n/**\n * Checks if the given string is a valid identifier name.\n *\n * Allows dashes, so it’s actually JSX identifier names.\n *\n * @param {string} name\n *   Whatever.\n * @returns {boolean}\n *   Whether `name` is a valid JSX identifier.\n */\nfunction jsxIdentifierName(name) {\n  let index = -1\n\n  while (++index < name.length) {\n    if (!(index ? cont : identifierStart)(name.charCodeAt(index))) return false\n  }\n\n  // `false` if `name` is empty.\n  return index > 0\n\n  /**\n   * @param {number} code\n   * @returns {boolean}\n   */\n  function cont(code) {\n    return identifierCont(code) || code === 45 /* `-` */\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 527, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 532, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@2.3.3/node_modules/hast-util-to-estree/lib/handlers/comment.js"],"sourcesContent":["/**\n * @typedef {import('estree').Comment} Comment\n * @typedef {import('estree-jsx').JSXExpressionContainer} JsxExpressionContainer\n * @typedef {import('estree-jsx').JSXEmptyExpression} JsxEmptyExpression\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * Turn a hast comment into an estree node.\n *\n * @param {import('hast').Comment} node\n *   hast node to transform.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {JsxExpressionContainer}\n *   estree expression.\n */\nexport function comment(node, state) {\n  /** @type {Comment} */\n  const result = {type: 'Block', value: node.value}\n  state.inherit(node, result)\n  state.comments.push(result)\n\n  /** @type {JsxEmptyExpression} */\n  const expression = {\n    type: 'JSXEmptyExpression',\n    // @ts-expect-error: `comments` is custom.\n    comments: [Object.assign({}, result, {leading: false, trailing: true})]\n  }\n  state.patch(node, expression)\n\n  /** @type {JsxExpressionContainer} */\n  const container = {type: 'JSXExpressionContainer', expression}\n  state.patch(node, container)\n  return container\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAED;;;;;;;;;CASC;;;AACM,SAAS,QAAQ,IAAI,EAAE,KAAK;IACjC,oBAAoB,GACpB,MAAM,SAAS;QAAC,MAAM;QAAS,OAAO,KAAK,KAAK;IAAA;IAChD,MAAM,OAAO,CAAC,MAAM;IACpB,MAAM,QAAQ,CAAC,IAAI,CAAC;IAEpB,+BAA+B,GAC/B,MAAM,aAAa;QACjB,MAAM;QACN,0CAA0C;QAC1C,UAAU;YAAC,OAAO,MAAM,CAAC,CAAC,GAAG,QAAQ;gBAAC,SAAS;gBAAO,UAAU;YAAI;SAAG;IACzE;IACA,MAAM,KAAK,CAAC,MAAM;IAElB,mCAAmC,GACnC,MAAM,YAAY;QAAC,MAAM;QAA0B;IAAU;IAC7D,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT"}},
    {"offset": {"line": 574, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 579, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@2.3.3/node_modules/hast-util-to-estree/lib/handlers/index.js"],"sourcesContent":["import {comment} from './comment.js'\nimport {element} from './element.js'\nimport {mdxExpression} from './mdx-expression.js'\nimport {mdxJsxElement} from './mdx-jsx-element.js'\nimport {mdxjsEsm} from './mdxjs-esm.js'\nimport {text} from './text.js'\nimport {root} from './root.js'\n\nexport const handlers = {\n  comment,\n  doctype: ignore,\n  element,\n  mdxFlowExpression: mdxExpression,\n  mdxTextExpression: mdxExpression,\n  mdxJsxFlowElement: mdxJsxElement,\n  mdxJsxTextElement: mdxJsxElement,\n  mdxjsEsm,\n  text,\n  root\n}\n\n/**\n * Handle a node that is ignored.\n *\n * @returns {void}\n *   Nothing.\n */\nfunction ignore() {}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAQO,MAAM,WAAW;IACtB,OAAO;IACP,SAAS;IACT,OAAO;IACP,iBAAiB;IACjB,iBAAiB;IACjB,iBAAiB;IACjB,iBAAiB;IACjB,QAAQ;IACR,IAAI;IACJ,IAAI;AACN;AAEA;;;;;CAKC,GACD,SAAS,UAAU"}},
    {"offset": {"line": 615, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 620, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@2.3.3/node_modules/hast-util-to-estree/lib/state.js"],"sourcesContent":["/**\n * @typedef {import('estree').Comment} Comment\n * @typedef {import('estree').Directive} Directive\n * @typedef {import('estree').ModuleDeclaration} ModuleDeclaration\n * @typedef {import('estree').Node} EstreeNode\n * @typedef {import('estree').Statement} Statement\n *\n * @typedef {import('estree-jsx').JSXAttribute} JsxAttribute\n * @typedef {import('estree-jsx').JSXElement} JsxElement\n * @typedef {import('estree-jsx').JSXIdentifier} JsxIdentifier\n * @typedef {import('estree-jsx').JSXMemberExpression} JsxMemberExpression\n * @typedef {import('estree-jsx').JSXNamespacedName} JsxNamespacedName\n *\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Root} Root\n *\n * @typedef {import('mdast-util-mdx-expression').MdxFlowExpression} MdxFlowExpression\n * @typedef {import('mdast-util-mdx-expression').MdxTextExpression} MdxTextExpression\n *\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxAttribute} MdxJsxAttribute\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxAttributeValueExpression} MdxJsxAttributeValueExpression\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxExpressionAttribute} MdxJsxExpressionAttribute\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxFlowElement} MdxJsxFlowElement\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxTextElement} MdxJsxTextElement\n *\n * @typedef {import('property-information').Schema} Schema\n *\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Content | MdxJsxAttributeValueExpression | MdxJsxAttribute | MdxJsxExpressionAttribute | MdxJsxFlowElement | MdxJsxTextElement | MdxFlowExpression | MdxTextExpression | Root} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n * @typedef {JsxElement['openingElement']['name']} JsxElementName\n * @typedef {JsxAttribute['name']} JsxAttributeName\n * @typedef {JsxElement['children'][number]} JsxChild\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n * @callback Handle\n *   Turn a hast node into an estree node.\n * @param {any} node\n *   Expected hast node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {JsxChild | null | undefined | void}\n *   estree node.\n *\n * @typedef {'html' | 'react'} ElementAttributeNameCase\n *   Specify casing to use for attribute names.\n *\n *   HTML casing is for example `class`, `stroke-linecap`, `xml:lang`.\n *   React casing is for example `className`, `strokeLinecap`, `xmlLang`.\n *\n * @typedef {'css' | 'dom'} StylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n *\n *   CSS casing is for example `background-color` and `-webkit-line-clamp`.\n *   DOM casing is for example `backgroundColor` and `WebkitLineClamp`.\n *\n * @typedef Options\n *   Configuration.\n * @property {ElementAttributeNameCase | null | undefined} [elementAttributeNameCase='react']\n *   Specify casing to use for attribute names.\n *\n *   This casing is used for hast elements, not for embedded MDX JSX nodes\n *   (components that someone authored manually).\n * @property {Record<string, Handle | null | undefined> | null | undefined} [handlers={}]\n *   Custom handlers.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in.\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {StylePropertyNameCase | null | undefined} [stylePropertyNameCase='dom']\n *   Specify casing to use for property names in `style` objects.\n *\n *   This casing is used for hast elements, not for embedded MDX JSX nodes\n *   (components that someone authored manually).\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {Schema} schema\n *   Current schema.\n * @property {ElementAttributeNameCase} elementAttributeNameCase\n *   Casing to use for attribute names.\n * @property {StylePropertyNameCase} stylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n * @property {Array<Comment>} comments\n *   List of estree comments.\n * @property {Array<Directive | Statement | ModuleDeclaration>} esm\n *   List of top-level estree nodes.\n * @property {(node: any) => JsxChild | null | undefined | void} handle\n *   Transform a hast node to estree.\n * @property {(parent: Parent) => Array<JsxChild>} all\n *   Transform children of a hast parent to estree.\n * @property {(from: Node, to: EstreeNode | Comment) => void} patch\n *   Take positional info from `from` (use `inherit` if you also want data).\n * @property {(from: Node, to: EstreeNode | Comment) => void} inherit\n *   Take positional info and data from `from` (use `patch` if you don’t want data).\n * @property {(name: string) => JsxAttributeName} createJsxAttributeName\n *   Create a JSX attribute name.\n * @property {(name: string) => JsxElementName} createJsxElementName\n *   Create a JSX element name.\n */\n\nimport {html, svg} from 'property-information'\nimport {position} from 'unist-util-position'\nimport {zwitch} from 'zwitch'\nimport {handlers} from './handlers/index.js'\n\nconst own = {}.hasOwnProperty\n\n// `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they don’t do here, so we remove all of\n// that.\n//\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\n// See: <https://github.com/mdx-js/mdx/issues/2000>\nconst tableElements = new Set(['table', 'thead', 'tbody', 'tfoot', 'tr'])\n\n/**\n * Create a state from options.\n *\n * @param {Options} options\n *   Configuration.\n * @returns {State}\n *   Info passed around about the current state.\n */\n\nexport function createState(options) {\n  /** @type {Handle} */\n  const one = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: {...handlers, ...options.handlers}\n  })\n\n  return {\n    // Current space.\n    schema: options.space === 'svg' ? svg : html,\n    elementAttributeNameCase: options.elementAttributeNameCase || 'react',\n    stylePropertyNameCase: options.stylePropertyNameCase || 'dom',\n    // Results.\n    comments: [],\n    esm: [],\n    // Useful functions.\n    handle,\n    all,\n    patch,\n    inherit,\n    createJsxAttributeName,\n    createJsxElementName\n  }\n\n  /**\n   * @this {State}\n   * @param {any} node\n   * @returns {JsxChild | null | undefined | void}\n   */\n  function handle(node) {\n    return one(node, this)\n  }\n}\n\n/**\n * Crash on an invalid value.\n *\n * @param {unknown} value\n *   Non-node.\n * @returns {never}\n *   Nothing (crashes).\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * Crash on an unknown node.\n *\n * @param {unknown} node\n *   Unknown node.\n * @returns {never}\n *   Nothing (crashes).\n */\nfunction unknown(node) {\n  // @ts-expect-error: JS guarantees there’s a `type`.\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/**\n * @this {State} state\n *   Info passed around about the current state.\n * @param {Parent | MdxJsxFlowElement | MdxJsxTextElement} parent\n *   hast node whose children to transform.\n * @returns {Array<JsxChild>}\n *   estree nodes.\n */\nfunction all(parent) {\n  const children = parent.children || []\n  let index = -1\n  /** @type {Array<JsxChild>} */\n  const results = []\n  const ignoreLineBreak =\n    this.schema.space === 'html' &&\n    parent.type === 'element' &&\n    tableElements.has(parent.tagName.toLowerCase())\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    if (ignoreLineBreak && child.type === 'text' && child.value === '\\n') {\n      continue\n    }\n\n    const result = this.handle(child)\n\n    if (Array.isArray(result)) {\n      results.push(...result)\n    } else if (result) {\n      results.push(result)\n    }\n  }\n\n  return results\n}\n\n/**\n * Take positional info and data from `hast`.\n *\n * Use `patch` if you don’t want data.\n *\n * @param {Node | MdxJsxAttributeValueExpression | MdxJsxAttribute | MdxJsxExpressionAttribute | MdxJsxFlowElement | MdxJsxTextElement | MdxFlowExpression | MdxTextExpression} from\n *   hast node to take positional info and data from.\n * @param {EstreeNode | Comment} to\n *   estree node to add positional info and data to.\n * @returns {void}\n *   Nothing.\n */\nfunction inherit(from, to) {\n  /** @type {Record<string, unknown> | undefined} */\n  const left = from.data\n  /** @type {Record<string, unknown> | undefined} */\n  let right\n  /** @type {string} */\n  let key\n\n  patch(from, to)\n\n  if (left) {\n    for (key in left) {\n      if (own.call(left, key) && key !== 'estree') {\n        if (!right) right = {}\n        right[key] = left[key]\n      }\n    }\n\n    if (right) {\n      // @ts-expect-error `esast` extension.\n      to.data = right\n    }\n  }\n}\n\n/**\n * Take positional info from `from`.\n *\n * Use `inherit` if you also want data.\n *\n * @param {Node | MdxJsxAttributeValueExpression | MdxJsxAttribute | MdxJsxExpressionAttribute | MdxJsxFlowElement | MdxJsxTextElement | MdxFlowExpression | MdxTextExpression} from\n *   hast node to take positional info from.\n * @param {EstreeNode | Comment} to\n *   estree node to add positional info to.\n * @returns {void}\n *   Nothing.\n */\nfunction patch(from, to) {\n  const p = position(from)\n\n  if (\n    p.start.line &&\n    p.start.offset !== undefined &&\n    p.end.offset !== undefined\n  ) {\n    // @ts-expect-error acorn-style.\n    to.start = p.start.offset\n    // @ts-expect-error acorn-style.\n    to.end = p.end.offset\n    to.loc = {\n      start: {line: p.start.line, column: p.start.column - 1},\n      end: {line: p.end.line, column: p.end.column - 1}\n    }\n    to.range = [p.start.offset, p.end.offset]\n  }\n}\n\n/**\n * Create a JSX attribute name.\n *\n * @param {string} name\n * @returns {JsxAttributeName}\n */\nfunction createJsxAttributeName(name) {\n  const node = createJsxNameFromString(name)\n\n  // MDX never generates this.\n  /* c8 ignore next 3 */\n  if (node.type === 'JSXMemberExpression') {\n    throw new Error('Member expressions in attribute names are not supported')\n  }\n\n  return node\n}\n\n/**\n * Create a JSX element name.\n *\n * @param {string} name\n * @returns {JsxElementName}\n */\nfunction createJsxElementName(name) {\n  return createJsxNameFromString(name)\n}\n\n/**\n * Create a JSX name from a string.\n *\n * @param {string} name\n *   Name.\n * @returns {JsxMemberExpression | JsxNamespacedName | JsxIdentifier}\n *   Node.\n */\nfunction createJsxNameFromString(name) {\n  if (name.includes('.')) {\n    const names = name.split('.')\n    let part = names.shift()\n    /** @type {JsxMemberExpression} */\n    // @ts-expect-error: hush, the first is always defined.\n    let node = {type: 'JSXIdentifier', name: part}\n\n    while ((part = names.shift())) {\n      node = {\n        type: 'JSXMemberExpression',\n        object: node,\n        property: {type: 'JSXIdentifier', name: part}\n      }\n    }\n\n    return node\n  }\n\n  if (name.includes(':')) {\n    const parts = name.split(':')\n    return {\n      type: 'JSXNamespacedName',\n      namespace: {type: 'JSXIdentifier', name: parts[0]},\n      name: {type: 'JSXIdentifier', name: parts[1]}\n    }\n  }\n\n  return {type: 'JSXIdentifier', name}\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 967, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 972, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@2.3.3/node_modules/hast-util-to-estree/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Root} Root\n *\n * @typedef {import('estree').ExpressionStatement} ExpressionStatement\n * @typedef {import('estree').Program} Program\n *\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxAttribute} MdxJsxAttribute\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxAttributeValueExpression} MdxJsxAttributeValueExpression\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxExpressionAttribute} MdxJsxExpressionAttribute\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxFlowElement} MdxJsxFlowElement\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxTextElement} MdxJsxTextElement\n *\n * @typedef {import('mdast-util-mdx-expression').MdxFlowExpression} MdxFlowExpression\n * @typedef {import('mdast-util-mdx-expression').MdxTextExpression} MdxTextExpression\n *\n * @typedef {import('./state.js').Options} Options\n */\n\n/**\n * @typedef {Root | Content | MdxJsxAttributeValueExpression | MdxJsxAttribute | MdxJsxExpressionAttribute | MdxJsxFlowElement | MdxJsxTextElement | MdxFlowExpression | MdxTextExpression} Node\n */\n\nimport {createState} from './state.js'\n\n/**\n * Transform a hast tree (with embedded MDX nodes) into an estree.\n *\n * ##### Notes\n *\n * ###### Comments\n *\n * Comments are attached to the tree in their neighbouring nodes (`recast`,\n * `babel` style) and also added as a `comments` array on the program node\n * (`espree` style).\n * You may have to do `program.comments = undefined` for certain compilers.\n *\n * ###### Frameworks\n *\n * There are differences between what JSX frameworks accept, such as whether they\n * accept `class` or `className`, or `background-color` or `backgroundColor`.\n *\n * For JSX components written in MDX, the author has to be aware of this\n * difference and write code accordingly.\n * For hast elements transformed by this project, this will be handled through\n * options.\n *\n * | Framework | `elementAttributeNameCase` | `stylePropertyNameCase` |\n * | --------- | -------------------------- | ----------------------- |\n * | Preact    | `'html'`                   | `'dom'`                 |\n * | React     | `'react'`                  | `'dom'`                 |\n * | Solid     | `'html'`                   | `'css'`                 |\n * | Vue       | `'html'`                   | `'dom'`                 |\n *\n * @param {Node} tree\n *   hast tree.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {Program}\n *   estree program node.\n *\n *   The program’s last child in `body` is most likely an `ExpressionStatement`,\n *   whose expression is a `JSXFragment` or a `JSXElement`.\n *\n *   Typically, there is only one node in `body`, however, this utility also\n *   supports embedded MDX nodes in the HTML (when `mdast-util-mdx` is used\n *   with mdast to parse markdown before passing its nodes through to hast).\n *   When MDX ESM import/exports are used, those nodes are added before the\n *   fragment or element in body.\n *\n *   There aren’t many great estree serializers out there that support JSX.\n *   To do that, you can use `estree-util-to-js`.\n *   Or, use `estree-util-build-jsx` to turn JSX into function calls, and then\n *   serialize with whatever (`astring`, `escodegen`).\n */\nexport function toEstree(tree, options) {\n  const state = createState(options || {})\n  let result = state.handle(tree)\n  const body = state.esm\n\n  if (result) {\n    if (result.type !== 'JSXFragment' && result.type !== 'JSXElement') {\n      result = {\n        type: 'JSXFragment',\n        openingFragment: {type: 'JSXOpeningFragment'},\n        closingFragment: {type: 'JSXClosingFragment'},\n        children: [result]\n      }\n      state.patch(tree, result)\n    }\n\n    /** @type {ExpressionStatement} */\n    // @ts-expect-error Types are wrong (`expression` *can* be JSX).\n    const statement = {type: 'ExpressionStatement', expression: result}\n    state.patch(tree, statement)\n    body.push(statement)\n  }\n\n  /** @type {Program} */\n  const program = {\n    type: 'Program',\n    body,\n    sourceType: 'module',\n    comments: state.comments\n  }\n  state.patch(tree, program)\n  return program\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;CAiBC,GAED;;CAEC;;;;;;AAsDM,SAAS,SAAS,IAAI,EAAE,OAAO;IACpC,MAAM,QAAQ,8OAAY,WAAW,CAAC;IACtC,IAAI,SAAS,MAAM,MAAM,CAAC;IAC1B,MAAM,OAAO,MAAM,GAAG;IAEtB,IAAI,QAAQ;QACV,IAAI,OAAO,IAAI,KAAK,iBAAiB,OAAO,IAAI,KAAK,cAAc;YACjE,SAAS;gBACP,MAAM;gBACN,iBAAiB;oBAAC,MAAM;gBAAoB;gBAC5C,iBAAiB;oBAAC,MAAM;gBAAoB;gBAC5C,UAAU;oBAAC;iBAAO;YACpB;YACA,MAAM,KAAK,CAAC,MAAM;QACpB;QAEA,gCAAgC,GAChC,gEAAgE;QAChE,MAAM,YAAY;YAAC,MAAM;YAAuB,YAAY;QAAM;QAClE,MAAM,KAAK,CAAC,MAAM;QAClB,KAAK,IAAI,CAAC;IACZ;IAEA,oBAAoB,GACpB,MAAM,UAAU;QACd,MAAM;QACN;QACA,YAAY;QACZ,UAAU,MAAM,QAAQ;IAC1B;IACA,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT"}},
    {"offset": {"line": 1034, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1039, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@2.3.3/node_modules/hast-util-to-estree/index.js"],"sourcesContent":["/**\n * @typedef {import('./lib/state.js').ElementAttributeNameCase} ElementAttributeNameCase\n * @typedef {import('./lib/state.js').Handle} Handle\n * @typedef {import('./lib/state.js').Options} Options\n * @typedef {import('./lib/state.js').Space} Space\n * @typedef {import('./lib/state.js').State} State\n * @typedef {import('./lib/state.js').StylePropertyNameCase} StylePropertyNameCase\n */\n\nexport {handlers as defaultHandlers} from './lib/handlers/index.js'\nexport {toEstree} from './lib/index.js'\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC"}},
    {"offset": {"line": 1055, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1060, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@3.1.0/node_modules/hast-util-to-estree/lib/handlers/text.js"],"sourcesContent":["/**\n * @typedef {import('estree').Literal} Literal\n *\n * @typedef {import('estree-jsx').JSXExpressionContainer} JsxExpressionContainer\n *\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn a hast text node into an estree node.\n *\n * @param {HastText} node\n *   hast node to transform.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {JsxExpressionContainer | undefined}\n *   JSX expression.\n */\nexport function text(node, state) {\n  const value = String(node.value || '')\n\n  if (value) {\n    /** @type {Literal} */\n    const result = {type: 'Literal', value}\n    state.inherit(node, result)\n    /** @type {JsxExpressionContainer} */\n    const container = {type: 'JSXExpressionContainer', expression: result}\n    state.patch(node, container)\n    return container\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;CAQC,GAED,mDAAmD;;;;AACnD;AAYO,SAAS,KAAK,IAAI,EAAE,KAAK;IAC9B,MAAM,QAAQ,OAAO,KAAK,KAAK,IAAI;IAEnC,IAAI,OAAO;QACT,oBAAoB,GACpB,MAAM,SAAS;YAAC,MAAM;YAAW;QAAK;QACtC,MAAM,OAAO,CAAC,MAAM;QACpB,mCAAmC,GACnC,MAAM,YAAY;YAAC,MAAM;YAA0B,YAAY;QAAM;QACrE,MAAM,KAAK,CAAC,MAAM;QAClB,OAAO;IACT;AACF"}},
    {"offset": {"line": 1089, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1094, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@3.1.0/node_modules/hast-util-to-estree/lib/handlers/root.js"],"sourcesContent":["/**\n * @typedef {import('estree-jsx').JSXFragment} JsxFragment\n *\n * @typedef {import('hast').Root} HastRoot\n *\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {JsxFragment['children'][number]} JsxChild\n */\n\nimport {whitespace} from 'hast-util-whitespace'\n\n/**\n * Turn a hast root node into an estree node.\n *\n * @param {HastRoot} node\n *   hast node to transform.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {JsxFragment}\n *   estree JSX fragment.\n */\nexport function root(node, state) {\n  const children = state.all(node)\n  /** @type {Array<JsxChild>} */\n  const cleanChildren = []\n  let index = -1\n  /** @type {Array<JsxChild> | undefined} */\n  let queue\n\n  // Remove surrounding whitespace nodes from the fragment.\n  while (++index < children.length) {\n    const child = children[index]\n\n    if (\n      child.type === 'JSXExpressionContainer' &&\n      child.expression.type === 'Literal' &&\n      whitespace(String(child.expression.value))\n    ) {\n      if (queue) queue.push(child)\n    } else {\n      if (queue) cleanChildren.push(...queue)\n      cleanChildren.push(child)\n      queue = []\n    }\n  }\n\n  /** @type {JsxFragment} */\n  const result = {\n    type: 'JSXFragment',\n    openingFragment: {type: 'JSXOpeningFragment'},\n    closingFragment: {type: 'JSXClosingFragment'},\n    children: cleanChildren\n  }\n  state.inherit(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC,GAED;;CAEC;;;;;;AAcM,SAAS,KAAK,IAAI,EAAE,KAAK;IAC9B,MAAM,WAAW,MAAM,GAAG,CAAC;IAC3B,4BAA4B,GAC5B,MAAM,gBAAgB,EAAE;IACxB,IAAI,QAAQ,CAAC;IACb,wCAAwC,GACxC,IAAI;IAEJ,yDAAyD;IACzD,MAAO,EAAE,QAAQ,SAAS,MAAM,CAAE;QAChC,MAAM,QAAQ,QAAQ,CAAC,MAAM;QAE7B,IACE,MAAM,IAAI,KAAK,4BACf,MAAM,UAAU,CAAC,IAAI,KAAK,aAC1B,kOAAW,OAAO,MAAM,UAAU,CAAC,KAAK,IACxC;YACA,IAAI,OAAO,MAAM,IAAI,CAAC;QACxB,OAAO;YACL,IAAI,OAAO,cAAc,IAAI,IAAI;YACjC,cAAc,IAAI,CAAC;YACnB,QAAQ,EAAE;QACZ;IACF;IAEA,wBAAwB,GACxB,MAAM,SAAS;QACb,MAAM;QACN,iBAAiB;YAAC,MAAM;QAAoB;QAC5C,iBAAiB;YAAC,MAAM;QAAoB;QAC5C,UAAU;IACZ;IACA,MAAM,OAAO,CAAC,MAAM;IACpB,OAAO;AACT"}},
    {"offset": {"line": 1137, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1142, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@3.1.0/node_modules/hast-util-to-estree/lib/handlers/mdxjs-esm.js"],"sourcesContent":["/**\n * @typedef {import('mdast-util-mdxjs-esm').MdxjsEsmHast} MdxjsEsm\n *\n * @typedef {import('../state.js').State} State\n */\n\nimport {attachComments} from 'estree-util-attach-comments'\n\n/**\n * Handle an MDX ESM node.\n *\n * @param {MdxjsEsm} node\n *   hast node to transform.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {undefined}\n *   Nothing.\n */\nexport function mdxjsEsm(node, state) {\n  const estree = node.data && node.data.estree\n  const comments = (estree && estree.comments) || []\n\n  if (estree) {\n    state.comments.push(...comments)\n    attachComments(estree, comments)\n    state.esm.push(...estree.body)\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;;;AAcM,SAAS,SAAS,IAAI,EAAE,KAAK;IAClC,MAAM,SAAS,KAAK,IAAI,IAAI,KAAK,IAAI,CAAC,MAAM;IAC5C,MAAM,WAAW,AAAC,UAAU,OAAO,QAAQ,IAAK,EAAE;IAElD,IAAI,QAAQ;QACV,MAAM,QAAQ,CAAC,IAAI,IAAI;QACvB,0PAAe,QAAQ;QACvB,MAAM,GAAG,CAAC,IAAI,IAAI,OAAO,IAAI;IAC/B;AACF"}},
    {"offset": {"line": 1161, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1166, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@3.1.0/node_modules/hast-util-to-estree/lib/handlers/mdx-jsx-element.js"],"sourcesContent":["/**\n * @typedef {import('estree').Expression} Expression\n *\n * @typedef {import('estree-jsx').JSXAttribute} JsxAttribute\n * @typedef {import('estree-jsx').JSXElement} JsxElement\n * @typedef {import('estree-jsx').JSXFragment} JsxFragment\n * @typedef {import('estree-jsx').JSXSpreadAttribute} JsxSpreadAttribute\n *\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxFlowElementHast} MdxJsxFlowElement\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxTextElementHast} MdxJsxTextElement\n *\n * @typedef {import('../state.js').State} State\n */\n\nimport {attachComments} from 'estree-util-attach-comments'\nimport {svg} from 'property-information'\n\n/**\n * Turn an MDX JSX element node into an estree node.\n *\n * @param {MdxJsxFlowElement | MdxJsxTextElement} node\n *   hast node to transform.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {JsxElement | JsxFragment}\n *   JSX element or fragment.\n */\n// eslint-disable-next-line complexity\nexport function mdxJsxElement(node, state) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n  const attrs = node.attributes || []\n  let index = -1\n\n  if (\n    node.name &&\n    parentSchema.space === 'html' &&\n    node.name.toLowerCase() === 'svg'\n  ) {\n    schema = svg\n    state.schema = schema\n  }\n\n  const children = state.all(node)\n  /** @type {Array<JsxAttribute | JsxSpreadAttribute>} */\n  const attributes = []\n\n  while (++index < attrs.length) {\n    const attr = attrs[index]\n    const value = attr.value\n    /** @type {JsxAttribute['value']} */\n    let attributeValue\n\n    if (attr.type === 'mdxJsxAttribute') {\n      if (value === null || value === undefined) {\n        attributeValue = null\n        // Empty.\n      }\n      // `MdxJsxAttributeValueExpression`.\n      else if (typeof value === 'object') {\n        const estree = value.data && value.data.estree\n        const comments = (estree && estree.comments) || []\n        /** @type {Expression | undefined} */\n        let expression\n\n        if (estree) {\n          state.comments.push(...comments)\n          attachComments(estree, estree.comments)\n          // Should exist.\n          /* c8 ignore next 5 */\n          expression =\n            (estree.body[0] &&\n              estree.body[0].type === 'ExpressionStatement' &&\n              estree.body[0].expression) ||\n            undefined\n        }\n\n        attributeValue = {\n          type: 'JSXExpressionContainer',\n          expression: expression || {type: 'JSXEmptyExpression'}\n        }\n        state.inherit(value, attributeValue)\n      }\n      // Anything else.\n      else {\n        attributeValue = {type: 'Literal', value: String(value)}\n      }\n\n      /** @type {JsxAttribute} */\n      const attribute = {\n        type: 'JSXAttribute',\n        name: state.createJsxAttributeName(attr.name),\n        value: attributeValue\n      }\n\n      state.inherit(attr, attribute)\n      attributes.push(attribute)\n    }\n    // MdxJsxExpressionAttribute.\n    else {\n      const estree = attr.data && attr.data.estree\n      const comments = (estree && estree.comments) || []\n      /** @type {JsxSpreadAttribute['argument'] | undefined} */\n      let argumentValue\n\n      if (estree) {\n        state.comments.push(...comments)\n        attachComments(estree, estree.comments)\n        // Should exist.\n        /* c8 ignore next 10 */\n        argumentValue =\n          (estree.body[0] &&\n            estree.body[0].type === 'ExpressionStatement' &&\n            estree.body[0].expression &&\n            estree.body[0].expression.type === 'ObjectExpression' &&\n            estree.body[0].expression.properties &&\n            estree.body[0].expression.properties[0] &&\n            estree.body[0].expression.properties[0].type === 'SpreadElement' &&\n            estree.body[0].expression.properties[0].argument) ||\n          undefined\n      }\n\n      /** @type {JsxSpreadAttribute} */\n      const attribute = {\n        type: 'JSXSpreadAttribute',\n        argument: argumentValue || {type: 'ObjectExpression', properties: []}\n      }\n      state.inherit(attr, attribute)\n      attributes.push(attribute)\n    }\n  }\n\n  // Restore parent schema.\n  state.schema = parentSchema\n\n  /** @type {JsxElement | JsxFragment} */\n  const result = node.name\n    ? {\n        type: 'JSXElement',\n        openingElement: {\n          type: 'JSXOpeningElement',\n          attributes,\n          name: state.createJsxElementName(node.name),\n          selfClosing: children.length === 0\n        },\n        closingElement:\n          children.length > 0\n            ? {\n                type: 'JSXClosingElement',\n                name: state.createJsxElementName(node.name)\n              }\n            : null,\n        children\n      }\n    : {\n        type: 'JSXFragment',\n        openingFragment: {type: 'JSXOpeningFragment'},\n        closingFragment: {type: 'JSXClosingFragment'},\n        children\n      }\n\n  state.inherit(node, result)\n  return result\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1284, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1289, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@3.1.0/node_modules/hast-util-to-estree/lib/handlers/mdx-expression.js"],"sourcesContent":["/**\n * @typedef {import('estree').Expression} Expression\n *\n * @typedef {import('estree-jsx').JSXEmptyExpression} JsxEmptyExpression\n * @typedef {import('estree-jsx').JSXExpressionContainer} JsxExpressionContainer\n *\n * @typedef {import('mdast-util-mdx-expression').MdxFlowExpressionHast} MdxFlowExpression\n * @typedef {import('mdast-util-mdx-expression').MdxTextExpressionHast} MdxTextExpression\n *\n * @typedef {import('../state.js').State} State\n */\n\nimport {attachComments} from 'estree-util-attach-comments'\n\n/**\n * Turn an MDX expression node into an estree node.\n *\n * @param {MdxFlowExpression | MdxTextExpression} node\n *   hast node to transform.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {JsxExpressionContainer}\n *   estree expression.\n */\nexport function mdxExpression(node, state) {\n  const estree = node.data && node.data.estree\n  const comments = (estree && estree.comments) || []\n  /** @type {Expression | JsxEmptyExpression | undefined} */\n  let expression\n\n  if (estree) {\n    state.comments.push(...comments)\n    attachComments(estree, estree.comments)\n    expression =\n      (estree.body[0] &&\n        estree.body[0].type === 'ExpressionStatement' &&\n        estree.body[0].expression) ||\n      undefined\n  }\n\n  if (!expression) {\n    expression = {type: 'JSXEmptyExpression'}\n    state.patch(node, expression)\n  }\n\n  /** @type {JsxExpressionContainer} */\n  const result = {type: 'JSXExpressionContainer', expression}\n  state.inherit(node, result)\n  return result\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;CAUC;;;;;;AAcM,SAAS,cAAc,IAAI,EAAE,KAAK;IACvC,MAAM,SAAS,KAAK,IAAI,IAAI,KAAK,IAAI,CAAC,MAAM;IAC5C,MAAM,WAAW,AAAC,UAAU,OAAO,QAAQ,IAAK,EAAE;IAClD,wDAAwD,GACxD,IAAI;IAEJ,IAAI,QAAQ;QACV,MAAM,QAAQ,CAAC,IAAI,IAAI;QACvB,0PAAe,QAAQ,OAAO,QAAQ;QACtC,aACE,AAAC,OAAO,IAAI,CAAC,EAAE,IACb,OAAO,IAAI,CAAC,EAAE,CAAC,IAAI,KAAK,yBACxB,OAAO,IAAI,CAAC,EAAE,CAAC,UAAU,IAC3B;IACJ;IAEA,IAAI,CAAC,YAAY;QACf,aAAa;YAAC,MAAM;QAAoB;QACxC,MAAM,KAAK,CAAC,MAAM;IACpB;IAEA,mCAAmC,GACnC,MAAM,SAAS;QAAC,MAAM;QAA0B;IAAU;IAC1D,MAAM,OAAO,CAAC,MAAM;IACpB,OAAO;AACT"}},
    {"offset": {"line": 1327, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1332, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@3.1.0/node_modules/hast-util-to-estree/lib/handlers/element.js"],"sourcesContent":["/**\n * @typedef {import('estree').Property} Property\n *\n * @typedef {import('estree-jsx').JSXAttribute} JsxAttribute\n * @typedef {import('estree-jsx').JSXElement} JsxElement\n * @typedef {import('estree-jsx').JSXSpreadAttribute} JsxSpreadAttribute\n *\n * @typedef {import('hast').Element} HastElement\n *\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Record<string, string>} Style\n */\n\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {name as identifierName} from 'estree-util-is-identifier-name'\nimport {find, hastToReact, svg} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport styleToObject from 'style-to-object'\n\nconst own = {}.hasOwnProperty\nconst cap = /[A-Z]/g\nconst dashSomething = /-([a-z])/g\n\nconst tableCellElement = new Set(['td', 'th'])\n\n/**\n * Turn a hast element into an estree node.\n *\n * @param {HastElement} node\n *   hast node to transform.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {JsxElement}\n *   estree expression.\n */\n// eslint-disable-next-line complexity\nexport function element(node, state) {\n  const parentSchema = state.schema\n  let schema = parentSchema\n  const props = node.properties || {}\n\n  if (parentSchema.space === 'html' && node.tagName.toLowerCase() === 'svg') {\n    schema = svg\n    state.schema = schema\n  }\n\n  const children = state.all(node)\n\n  /** @type {Array<JsxAttribute | JsxSpreadAttribute>} */\n  const attributes = []\n  /** @type {string} */\n  let prop\n  /** @type {string | undefined} */\n  let alignValue\n  /** @type {Array<Property> | undefined} */\n  let styleProperties\n\n  for (prop in props) {\n    if (own.call(props, prop)) {\n      let value = props[prop]\n      const info = find(schema, prop)\n      /** @type {JsxAttribute['value']} */\n      let attributeValue\n\n      // Ignore nullish and `NaN` values.\n      // Ignore `false` and falsey known booleans.\n      if (\n        value === null ||\n        value === undefined ||\n        value === false ||\n        (typeof value === 'number' && Number.isNaN(value)) ||\n        (!value && info.boolean)\n      ) {\n        continue\n      }\n\n      prop =\n        state.elementAttributeNameCase === 'react' && info.space\n          ? hastToReact[info.property] || info.property\n          : info.attribute\n\n      if (Array.isArray(value)) {\n        // Accept `array`.\n        // Most props are space-separated.\n        value = info.commaSeparated ? commas(value) : spaces(value)\n      }\n\n      if (prop === 'style') {\n        let styleObject =\n          typeof value === 'object'\n            ? value\n            : parseStyle(String(value), node.tagName)\n\n        if (state.stylePropertyNameCase === 'css') {\n          styleObject = transformStylesToCssCasing(styleObject)\n        }\n\n        /** @type {Array<Property>} */\n        const cssProperties = []\n        /** @type {string} */\n        let cssProp\n\n        for (cssProp in styleObject) {\n          // eslint-disable-next-line max-depth\n          if (own.call(styleObject, cssProp)) {\n            cssProperties.push({\n              type: 'Property',\n              method: false,\n              shorthand: false,\n              computed: false,\n              key: identifierName(cssProp)\n                ? {type: 'Identifier', name: cssProp}\n                : {type: 'Literal', value: cssProp},\n              value: {type: 'Literal', value: String(styleObject[cssProp])},\n              kind: 'init'\n            })\n          }\n        }\n\n        styleProperties = cssProperties\n        attributeValue = {\n          type: 'JSXExpressionContainer',\n          expression: {type: 'ObjectExpression', properties: cssProperties}\n        }\n      } else if (value === true) {\n        attributeValue = null\n      } else if (\n        state.tableCellAlignToStyle &&\n        tableCellElement.has(node.tagName) &&\n        prop === 'align'\n      ) {\n        alignValue = String(value)\n        continue\n      } else {\n        attributeValue = {type: 'Literal', value: String(value)}\n      }\n\n      if (identifierName(prop, {jsx: true})) {\n        attributes.push({\n          type: 'JSXAttribute',\n          name: {type: 'JSXIdentifier', name: prop},\n          value: attributeValue\n        })\n      } else {\n        attributes.push({\n          type: 'JSXSpreadAttribute',\n          argument: {\n            type: 'ObjectExpression',\n            properties: [\n              {\n                type: 'Property',\n                method: false,\n                shorthand: false,\n                computed: false,\n                key: {type: 'Literal', value: String(prop)},\n                // @ts-expect-error No need to worry about `style` (which has a\n                // `JSXExpressionContainer` value) because that’s a valid identifier.\n                value: attributeValue || {type: 'Literal', value: true},\n                kind: 'init'\n              }\n            ]\n          }\n        })\n      }\n    }\n  }\n\n  if (alignValue !== undefined) {\n    if (!styleProperties) {\n      styleProperties = []\n      attributes.push({\n        type: 'JSXAttribute',\n        name: {type: 'JSXIdentifier', name: 'style'},\n        value: {\n          type: 'JSXExpressionContainer',\n          expression: {type: 'ObjectExpression', properties: styleProperties}\n        }\n      })\n    }\n\n    const cssProp =\n      state.stylePropertyNameCase === 'css'\n        ? transformStyleToCssCasing('textAlign')\n        : 'textAlign'\n\n    styleProperties.push({\n      type: 'Property',\n      method: false,\n      shorthand: false,\n      computed: false,\n      key: identifierName(cssProp)\n        ? {type: 'Identifier', name: cssProp}\n        : {type: 'Literal', value: cssProp},\n      value: {type: 'Literal', value: alignValue},\n      kind: 'init'\n    })\n  }\n\n  // Restore parent schema.\n  state.schema = parentSchema\n\n  /** @type {JsxElement} */\n  const result = {\n    type: 'JSXElement',\n    openingElement: {\n      type: 'JSXOpeningElement',\n      attributes,\n      name: state.createJsxElementName(node.tagName),\n      selfClosing: children.length === 0\n    },\n    closingElement:\n      children.length > 0\n        ? {\n            type: 'JSXClosingElement',\n            name: state.createJsxElementName(node.tagName)\n          }\n        : null,\n    children\n  }\n  state.inherit(node, result)\n  return result\n}\n\n/**\n * Parse CSS rules as a declaration.\n *\n * @param {string} value\n *   CSS text.\n * @param {string} tagName\n *   Element name.\n * @returns {Style}\n *   Props.\n */\nfunction parseStyle(value, tagName) {\n  /** @type {Style} */\n  const result = {}\n\n  try {\n    styleToObject(value, iterator)\n  } catch (error) {\n    const cause = /** @type {Error} */ (error)\n    const exception = new Error(\n      'Could not parse `style` attribute on `' + tagName + '`',\n      {cause}\n    )\n    throw exception\n  }\n\n  return result\n\n  /**\n   * Add `name`, as a CSS prop, to `result`.\n   *\n   * @param {string} name\n   *   Key.\n   * @param {string} value\n   *   Value.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function iterator(name, value) {\n    let key = name\n\n    if (key.slice(0, 2) !== '--') {\n      // See: <https://alanhogan.com/code/vendor-prefixed-css-property-names-in-javascript>\n      if (key.slice(0, 4) === '-ms-') key = 'ms-' + key.slice(4)\n      key = key.replace(dashSomething, toCamel)\n    }\n\n    result[key] = value\n  }\n}\n\n/**\n * Transform a DOM casing style object to a CSS casing style object.\n *\n * @param {Style} domCasing\n * @returns {Style}\n */\nfunction transformStylesToCssCasing(domCasing) {\n  /** @type {Style} */\n  const cssCasing = {}\n  /** @type {string} */\n  let from\n\n  for (from in domCasing) {\n    if (own.call(domCasing, from)) {\n      cssCasing[transformStyleToCssCasing(from)] = domCasing[from]\n    }\n  }\n\n  return cssCasing\n}\n\n/**\n * Transform a DOM casing style prop to a CSS casing style prop.\n *\n * @param {string} from\n * @returns {string}\n */\nfunction transformStyleToCssCasing(from) {\n  let to = from.replace(cap, toDash)\n  // Handle `ms-xxx` -> `-ms-xxx`.\n  if (to.slice(0, 3) === 'ms-') to = '-' + to\n  return to\n}\n\n/**\n * Make `$1` capitalized.\n *\n * @param {string} _\n *   Whatever.\n * @param {string} $1\n *   Single ASCII alphabetical.\n * @returns {string}\n *   Capitalized `$1`.\n */\nfunction toCamel(_, $1) {\n  return $1.toUpperCase()\n}\n\n/**\n * Make `$0` dash cased.\n *\n * @param {string} $0\n *   Capitalized ASCII leter.\n * @returns {string}\n *   Dash and lower letter.\n */\nfunction toDash($0) {\n  return '-' + $0.toLowerCase()\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1628, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1633, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@3.1.0/node_modules/hast-util-to-estree/lib/handlers/comment.js"],"sourcesContent":["/**\n * @typedef {import('estree').Comment} Comment\n *\n * @typedef {import('estree-jsx').JSXEmptyExpression} JsxEmptyExpression\n * @typedef {import('estree-jsx').JSXExpressionContainer} JsxExpressionContainer\n *\n * @typedef {import('hast').Comment} HastComment\n *\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn a hast comment into an estree node.\n *\n * @param {HastComment} node\n *   hast node to transform.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {JsxExpressionContainer}\n *   estree expression.\n */\nexport function comment(node, state) {\n  /** @type {Comment} */\n  const result = {type: 'Block', value: node.value}\n  state.inherit(node, result)\n  state.comments.push(result)\n\n  /** @type {JsxEmptyExpression} */\n  const expression = {\n    type: 'JSXEmptyExpression',\n    // @ts-expect-error: `comments` is custom.\n    comments: [Object.assign({}, result, {leading: false, trailing: true})]\n  }\n  state.patch(node, expression)\n\n  /** @type {JsxExpressionContainer} */\n  const container = {type: 'JSXExpressionContainer', expression}\n  state.patch(node, container)\n  return container\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC,GAED,mDAAmD;;;;AACnD;AAYO,SAAS,QAAQ,IAAI,EAAE,KAAK;IACjC,oBAAoB,GACpB,MAAM,SAAS;QAAC,MAAM;QAAS,OAAO,KAAK,KAAK;IAAA;IAChD,MAAM,OAAO,CAAC,MAAM;IACpB,MAAM,QAAQ,CAAC,IAAI,CAAC;IAEpB,+BAA+B,GAC/B,MAAM,aAAa;QACjB,MAAM;QACN,0CAA0C;QAC1C,UAAU;YAAC,OAAO,MAAM,CAAC,CAAC,GAAG,QAAQ;gBAAC,SAAS;gBAAO,UAAU;YAAI;SAAG;IACzE;IACA,MAAM,KAAK,CAAC,MAAM;IAElB,mCAAmC,GACnC,MAAM,YAAY;QAAC,MAAM;QAA0B;IAAU;IAC7D,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT"}},
    {"offset": {"line": 1672, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1677, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@3.1.0/node_modules/hast-util-to-estree/lib/handlers/index.js"],"sourcesContent":["import {comment} from './comment.js'\nimport {element} from './element.js'\nimport {mdxExpression} from './mdx-expression.js'\nimport {mdxJsxElement} from './mdx-jsx-element.js'\nimport {mdxjsEsm} from './mdxjs-esm.js'\nimport {root} from './root.js'\nimport {text} from './text.js'\n\nexport const handlers = {\n  comment,\n  doctype: ignore,\n  element,\n  mdxFlowExpression: mdxExpression,\n  mdxJsxFlowElement: mdxJsxElement,\n  mdxJsxTextElement: mdxJsxElement,\n  mdxTextExpression: mdxExpression,\n  mdxjsEsm,\n  root,\n  text\n}\n\n/**\n * Handle a node that is ignored.\n *\n * @returns {undefined}\n *   Nothing.\n */\nfunction ignore() {}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAQO,MAAM,WAAW;IACtB,OAAO;IACP,SAAS;IACT,OAAO;IACP,iBAAiB;IACjB,iBAAiB;IACjB,iBAAiB;IACjB,iBAAiB;IACjB,QAAQ;IACR,IAAI;IACJ,IAAI;AACN;AAEA;;;;;CAKC,GACD,SAAS,UAAU"}},
    {"offset": {"line": 1713, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1718, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@3.1.0/node_modules/hast-util-to-estree/lib/state.js"],"sourcesContent":["/**\n * @typedef {import('estree').Comment} Comment\n * @typedef {import('estree').Directive} Directive\n * @typedef {import('estree').ModuleDeclaration} ModuleDeclaration\n * @typedef {import('estree').Node} EstreeNode\n * @typedef {import('estree').Statement} Statement\n *\n * @typedef {import('estree-jsx').JSXAttribute} JsxAttribute\n * @typedef {import('estree-jsx').JSXElement} JsxElement\n * @typedef {import('estree-jsx').JSXIdentifier} JsxIdentifier\n * @typedef {import('estree-jsx').JSXMemberExpression} JsxMemberExpression\n * @typedef {import('estree-jsx').JSXNamespacedName} JsxNamespacedName\n *\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxAttribute} MdxJsxAttribute\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxAttributeValueExpression} MdxJsxAttributeValueExpression\n * @typedef {import('mdast-util-mdx-jsx').MdxJsxExpressionAttribute} MdxJsxExpressionAttribute\n *\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('hast').Parents} HastParents\n *\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef {JsxElement['openingElement']['name']} JsxElementName\n * @typedef {JsxAttribute['name']} JsxAttributeName\n * @typedef {JsxElement['children'][number]} JsxChild\n */\n\n/**\n * @typedef {'html' | 'react'} ElementAttributeNameCase\n *   Specify casing to use for attribute names.\n *\n *   HTML casing is for example `class`, `stroke-linecap`, `xml:lang`.\n *   React casing is for example `className`, `strokeLinecap`, `xmlLang`.\n *\n * @callback Handle\n *   Turn a hast node into an estree node.\n * @param {any} node\n *   Expected hast node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {JsxChild | null | undefined}\n *   estree node.\n *\n * @typedef Options\n *   Configuration.\n * @property {ElementAttributeNameCase | null | undefined} [elementAttributeNameCase='react']\n *   Specify casing to use for attribute names (default: `'react'`).\n *\n *   This casing is used for hast elements, not for embedded MDX JSX nodes\n *   (components that someone authored manually).\n * @property {Record<string, Handle | null | undefined> | null | undefined} [handlers={}]\n *   Custom handlers (optional).\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in (default: `'html'`).\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {StylePropertyNameCase | null | undefined} [stylePropertyNameCase='dom']\n *   Specify casing to use for property names in `style` objects (default: `'dom'`).\n *\n *   This casing is used for hast elements, not for embedded MDX JSX nodes\n *   (components that someone authored manually).\n * @property {boolean | null | undefined} [tableCellAlignToStyle=true]\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props\n *   (default: `true`).\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n * @typedef {'css' | 'dom'} StylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n *\n *   CSS casing is for example `background-color` and `-webkit-line-clamp`.\n *   DOM casing is for example `backgroundColor` and `WebkitLineClamp`.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {(parent: HastParents) => Array<JsxChild>} all\n *   Transform children of a hast parent to estree.\n * @property {Array<Comment>} comments\n *   List of estree comments.\n * @property {(name: string) => JsxAttributeName} createJsxAttributeName\n *   Create a JSX attribute name.\n * @property {(name: string) => JsxElementName} createJsxElementName\n *   Create a JSX element name.\n * @property {ElementAttributeNameCase} elementAttributeNameCase\n *   Casing to use for attribute names.\n * @property {Array<Directive | ModuleDeclaration | Statement>} esm\n *   List of top-level estree nodes.\n * @property {(node: any) => JsxChild | null | undefined} handle\n *   Transform a hast node to estree.\n * @property {(from: HastNodes | MdxJsxAttribute | MdxJsxAttributeValueExpression | MdxJsxExpressionAttribute, to: Comment | EstreeNode) => undefined} inherit\n *   Take positional info and data from `from` (use `patch` if you don’t want data).\n * @property {(from: HastNodes, to: Comment | EstreeNode) => undefined} patch\n *   Take positional info from `from` (use `inherit` if you also want data).\n * @property {Schema} schema\n *   Current schema.\n * @property {StylePropertyNameCase} stylePropertyNameCase\n *   Casing to use for property names in `style` objects.\n * @property {boolean} tableCellAlignToStyle\n *   Turn obsolete `align` props on `td` and `th` into CSS `style` props.\n */\n\nimport {ok as assert} from 'devlop'\nimport {html, svg} from 'property-information'\nimport {position} from 'unist-util-position'\nimport {zwitch} from 'zwitch'\nimport {handlers} from './handlers/index.js'\n\nconst own = {}.hasOwnProperty\n\n// `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they don’t do here, so we remove all of\n// that.\n//\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\n// See: <https://github.com/mdx-js/mdx/issues/2000>\nconst tableElements = new Set(['table', 'tbody', 'thead', 'tfoot', 'tr'])\n\n/**\n * Create a state from options.\n *\n * @param {Options} options\n *   Configuration.\n * @returns {State}\n *   Info passed around about the current state.\n */\n\nexport function createState(options) {\n  /** @type {Handle} */\n  const one = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: {...handlers, ...options.handlers}\n  })\n\n  return {\n    // Current space.\n    elementAttributeNameCase: options.elementAttributeNameCase || 'react',\n    schema: options.space === 'svg' ? svg : html,\n    stylePropertyNameCase: options.stylePropertyNameCase || 'dom',\n    tableCellAlignToStyle: options.tableCellAlignToStyle !== false,\n    // Results.\n    comments: [],\n    esm: [],\n    // Useful functions.\n    all,\n    createJsxAttributeName,\n    createJsxElementName,\n    handle,\n    inherit,\n    patch\n  }\n\n  /**\n   * @this {State}\n   * @param {any} node\n   * @returns {JsxChild | null | undefined}\n   */\n  function handle(node) {\n    return one(node, this)\n  }\n}\n\n/**\n * Crash on an invalid value.\n *\n * @param {unknown} value\n *   Non-node.\n * @returns {never}\n *   Nothing (crashes).\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * Crash on an unknown node.\n *\n * @param {unknown} node\n *   Unknown node.\n * @returns {never}\n *   Nothing (crashes).\n */\nfunction unknown(node) {\n  assert(node && typeof node === 'object')\n  assert('type' in node)\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/**\n * @this {State} state\n *   Info passed around about the current state.\n * @param {HastParents} parent\n *   hast node whose children to transform.\n * @returns {Array<JsxChild>}\n *   estree nodes.\n */\nfunction all(parent) {\n  const children = parent.children || []\n  let index = -1\n  /** @type {Array<JsxChild>} */\n  const results = []\n  const ignoreLineBreak =\n    this.schema.space === 'html' &&\n    parent.type === 'element' &&\n    tableElements.has(parent.tagName.toLowerCase())\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    if (ignoreLineBreak && child.type === 'text' && child.value === '\\n') {\n      continue\n    }\n\n    const result = this.handle(child)\n\n    if (Array.isArray(result)) {\n      results.push(...result)\n    } else if (result) {\n      results.push(result)\n    }\n  }\n\n  return results\n}\n\n/**\n * Take positional info and data from `hast`.\n *\n * Use `patch` if you don’t want data.\n *\n * @param {HastNodes | MdxJsxAttribute | MdxJsxAttributeValueExpression | MdxJsxExpressionAttribute} from\n *   hast node to take positional info and data from.\n * @param {Comment | EstreeNode} to\n *   estree node to add positional info and data to.\n * @returns {undefined}\n *   Nothing.\n */\nfunction inherit(from, to) {\n  const left = /** @type {Record<string, unknown> | undefined} */ (from.data)\n  /** @type {Record<string, unknown> | undefined} */\n  let right\n  /** @type {string} */\n  let key\n\n  patch(from, to)\n\n  if (left) {\n    for (key in left) {\n      if (own.call(left, key) && key !== 'estree') {\n        if (!right) right = {}\n        right[key] = left[key]\n      }\n    }\n\n    if (right) {\n      // @ts-expect-error `esast` extension.\n      to.data = right\n    }\n  }\n}\n\n/**\n * Take positional info from `from`.\n *\n * Use `inherit` if you also want data.\n *\n * @param {HastNodes | MdxJsxAttribute | MdxJsxAttributeValueExpression | MdxJsxExpressionAttribute} from\n *   hast node to take positional info from.\n * @param {Comment | EstreeNode} to\n *   estree node to add positional info to.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(from, to) {\n  const p = position(from)\n\n  if (p && p.start.offset !== undefined && p.end.offset !== undefined) {\n    // @ts-expect-error acorn-style.\n    to.start = p.start.offset\n    // @ts-expect-error acorn-style.\n    to.end = p.end.offset\n    to.loc = {\n      start: {line: p.start.line, column: p.start.column - 1},\n      end: {line: p.end.line, column: p.end.column - 1}\n    }\n    to.range = [p.start.offset, p.end.offset]\n  }\n}\n\n/**\n * Create a JSX attribute name.\n *\n * @param {string} name\n * @returns {JsxAttributeName}\n */\nfunction createJsxAttributeName(name) {\n  const node = createJsxNameFromString(name)\n\n  // MDX never generates this.\n  /* c8 ignore next 3 */\n  if (node.type === 'JSXMemberExpression') {\n    throw new Error('Member expressions in attribute names are not supported')\n  }\n\n  return node\n}\n\n/**\n * Create a JSX element name.\n *\n * @param {string} name\n * @returns {JsxElementName}\n */\nfunction createJsxElementName(name) {\n  return createJsxNameFromString(name)\n}\n\n/**\n * Create a JSX name from a string.\n *\n * @param {string} name\n *   Name.\n * @returns {JsxIdentifier | JsxMemberExpression | JsxNamespacedName}\n *   Node.\n */\nfunction createJsxNameFromString(name) {\n  if (name.includes('.')) {\n    const names = name.split('.')\n    let part = names.shift()\n    assert(part, 'Expected `part` to be defined')\n    /** @type {JsxIdentifier | JsxMemberExpression} */\n    let node = {type: 'JSXIdentifier', name: part}\n\n    while ((part = names.shift())) {\n      node = {\n        type: 'JSXMemberExpression',\n        object: node,\n        property: {type: 'JSXIdentifier', name: part}\n      }\n    }\n\n    return node\n  }\n\n  if (name.includes(':')) {\n    const parts = name.split(':')\n    return {\n      type: 'JSXNamespacedName',\n      namespace: {type: 'JSXIdentifier', name: parts[0]},\n      name: {type: 'JSXIdentifier', name: parts[1]}\n    }\n  }\n\n  return {type: 'JSXIdentifier', name}\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2065, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2070, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@3.1.0/node_modules/hast-util-to-estree/lib/index.js"],"sourcesContent":["/**\n * Register MDX nodes in tree:\n *\n * @typedef {import('mdast-util-mdx-expression')}\n * @typedef {import('mdast-util-mdx-jsx')}\n * @typedef {import('mdast-util-mdxjs-esm')}\n */\n\n/**\n * @typedef {import('estree').ExpressionStatement} ExpressionStatement\n * @typedef {import('estree').Program} Program\n *\n * @typedef {import('hast').Nodes} HastNodes\n *\n * @typedef {import('./state.js').Options} Options\n */\n\nimport {createState} from './state.js'\n\n/**\n * Transform a hast tree (with embedded MDX nodes) into an estree.\n *\n * ##### Notes\n *\n * ###### Comments\n *\n * Comments are attached to the tree in their neighbouring nodes (`recast`,\n * `babel` style) and also added as a `comments` array on the program node\n * (`espree` style).\n * You may have to do `program.comments = undefined` for certain compilers.\n *\n * ###### Frameworks\n *\n * There are differences between what JSX frameworks accept, such as whether they\n * accept `class` or `className`, or `background-color` or `backgroundColor`.\n *\n * For JSX components written in MDX, the author has to be aware of this\n * difference and write code accordingly.\n * For hast elements transformed by this project, this will be handled through\n * options.\n *\n * | Framework | `elementAttributeNameCase` | `stylePropertyNameCase` |\n * | --------- | -------------------------- | ----------------------- |\n * | Preact    | `'html'`                   | `'dom'`                 |\n * | React     | `'react'`                  | `'dom'`                 |\n * | Solid     | `'html'`                   | `'css'`                 |\n * | Vue       | `'html'`                   | `'dom'`                 |\n *\n * @param {HastNodes} tree\n *   hast tree.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Program}\n *   estree program node.\n *\n *   The program’s last child in `body` is most likely an `ExpressionStatement`,\n *   whose expression is a `JSXFragment` or a `JSXElement`.\n *\n *   Typically, there is only one node in `body`, however, this utility also\n *   supports embedded MDX nodes in the HTML (when `mdast-util-mdx` is used\n *   with mdast to parse markdown before passing its nodes through to hast).\n *   When MDX ESM import/exports are used, those nodes are added before the\n *   fragment or element in body.\n *\n *   There aren’t many great estree serializers out there that support JSX.\n *   To do that, you can use `estree-util-to-js`.\n *   Or, use `estree-util-build-jsx` to turn JSX into function calls, and then\n *   serialize with whatever (`astring`, `escodegen`).\n */\nexport function toEstree(tree, options) {\n  const state = createState(options || {})\n  let result = state.handle(tree)\n  const body = state.esm\n\n  if (result) {\n    if (result.type !== 'JSXFragment' && result.type !== 'JSXElement') {\n      result = {\n        type: 'JSXFragment',\n        openingFragment: {type: 'JSXOpeningFragment'},\n        closingFragment: {type: 'JSXClosingFragment'},\n        children: [result]\n      }\n      state.patch(tree, result)\n    }\n\n    /** @type {ExpressionStatement} */\n    // @ts-expect-error: `estree` types don’t allow JSX.\n    const statement = {type: 'ExpressionStatement', expression: result}\n    state.patch(tree, statement)\n    body.push(statement)\n  }\n\n  /** @type {Program} */\n  const program = {\n    type: 'Program',\n    body,\n    sourceType: 'module',\n    comments: state.comments\n  }\n  state.patch(tree, program)\n  return program\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC,GAED;;;;;;;CAOC;;;;;;AAsDM,SAAS,SAAS,IAAI,EAAE,OAAO;IACpC,MAAM,QAAQ,8OAAY,WAAW,CAAC;IACtC,IAAI,SAAS,MAAM,MAAM,CAAC;IAC1B,MAAM,OAAO,MAAM,GAAG;IAEtB,IAAI,QAAQ;QACV,IAAI,OAAO,IAAI,KAAK,iBAAiB,OAAO,IAAI,KAAK,cAAc;YACjE,SAAS;gBACP,MAAM;gBACN,iBAAiB;oBAAC,MAAM;gBAAoB;gBAC5C,iBAAiB;oBAAC,MAAM;gBAAoB;gBAC5C,UAAU;oBAAC;iBAAO;YACpB;YACA,MAAM,KAAK,CAAC,MAAM;QACpB;QAEA,gCAAgC,GAChC,oDAAoD;QACpD,MAAM,YAAY;YAAC,MAAM;YAAuB,YAAY;QAAM;QAClE,MAAM,KAAK,CAAC,MAAM;QAClB,KAAK,IAAI,CAAC;IACZ;IAEA,oBAAoB,GACpB,MAAM,UAAU;QACd,MAAM;QACN;QACA,YAAY;QACZ,UAAU,MAAM,QAAQ;IAC1B;IACA,MAAM,KAAK,CAAC,MAAM;IAClB,OAAO;AACT"}},
    {"offset": {"line": 2126, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2131, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/.pnpm/hast-util-to-estree@3.1.0/node_modules/hast-util-to-estree/index.js"],"sourcesContent":["/**\n * @typedef {import('./lib/state.js').ElementAttributeNameCase} ElementAttributeNameCase\n * @typedef {import('./lib/state.js').Handle} Handle\n * @typedef {import('./lib/state.js').Options} Options\n * @typedef {import('./lib/state.js').Space} Space\n * @typedef {import('./lib/state.js').State} State\n * @typedef {import('./lib/state.js').StylePropertyNameCase} StylePropertyNameCase\n */\n\nexport {handlers as defaultHandlers} from './lib/handlers/index.js'\nexport {toEstree} from './lib/index.js'\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC"}},
    {"offset": {"line": 2147, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}